extrn GetStdHandle		:proc
extrn ReadFile			:proc
extrn WriteFile			:proc
extrn GetProcessHeap	:proc
extrn HeapAlloc			:proc
extrn ExitProcess		:proc

.data
	sSize	db "Nhap kich thuoc mang = ", 0h
	sArrReq	db "Nhap tung phan tu cua mang = ", 0h
	sOdd	db "Sum Odd = ", 0h
	sEven	db "Sum Even = ", 0h

.data?
	buffer	db 1000 dup(?)
	Arr		dd 100 dup(?)
	OddSum	dd 0
	EvenSum	dd 0
	nByte	dd 0
	sArr	dd 0

.code
main proc
	mov		rbp, rsp
	sub		rsp, 48h			;shadow space + align + local variable

	mov		rcx, -10
	call	GetStdHandle
	mov		[rbp - 08h], rax				;STD_INPUT_HANDLE
	mov		rcx, -11
	call	GetStdHandle
	mov		[rbp - 10h], rax				;STD_OUTPUT_HANDLE

	xor		r15, r15

	mov		rcx, [rbp - 10h]
	mov		rdx, offset sSize
	mov		r8, sizeof sSize
	mov		r9, offset nByte
	mov		[rsp + 20h], r15
	call	WriteFile						;write text "nhap..... = "

	mov		rcx, [rbp - 08h]
	mov		rdx, offset Buffer
	mov		r8, 10
	mov		r9, offset nByte
	mov		[rsp + 20h], r15	
	call	ReadFile						;read size array
	mov		rsi, offset Buffer
	call	atoi							;atoi(rsi = &num --> eax = (int)num)
	mov		sArr, eax						;sArr = Size array

	mov		rcx, [rbp - 10h]
	mov		rdx, offset sArrReq
	mov		r8, sizeof sArrReq
	mov		r9, offset nByte
	mov		[rsp + 20h], r15
	call	WriteFile						;write text "nhap ptu ..... = "

	xor		rbx, rbx
	@ArrReq:
		mov		rcx, [rbp - 08h]
		mov		rdx, offset buffer
		mov		r8, 1000
		mov		r9, offset nByte
		mov		[rsp + 20h], r15
		call	ReadFile					;read data array

		mov		rsi, offset buffer			;rsi = &buffer
		mov		r14, offset Arr				;r14 = &arrSave

	@HandleArr:
		push	rsi							;push &buffer
		call	atoi						;atoi(rsi = &string --> return rax = number)
		mov		dword ptr [r14 + rbx*4], eax			;r14 = &savearr = array save number 
		inc		ebx
		cmp		ebx, sArr					;rbx = count number of number of array
		jz		@DoneArr	
		pop		rsi							

	@NextArr:
		cmp		byte ptr [rsi], 0Dh			;cmp string with \r
		jz		@ArrReq
		inc		rsi					
		cmp		byte ptr [rsi - 1], 20h		;cmp string[i-1] with " " 
		jz		@HandleArr
		jmp		@NextArr

	@DoneArr:
		mov		r13, offset Arr				;r13 = array int read
		xor		r8, r8
		xor		r9, r9
		mov		r14d, 2						;r14 = 2
		mov		rcx, 0

	@Check:
		xor		rdx, rdx
		xor		rax, rax
		mov		eax, dword ptr [r13]
		div		r14d						;array[i] / 2
		cmp		dl, 1						;odd
		jz		@CalcOdd
		mov		eax, dword ptr [r13]
		add		r8, rax						;r8 = sumodd
		jmp		@IncArr

	@CalcOdd:
		mov		eax, dword ptr [r13]
		add		r9, rax						;r9 = sumeven

	@IncArr:
		add		r13, 4						;array ++
		inc		ecx
		cmp		ecx, sArr					;count == size arr --> jmp
		jnz		@Check

	mov		OddSum, r9d						;r9d = sumodd
	mov		EvenSum, r8d					;r8d = sumeven
	;write even
	mov		rcx, [rbp - 10h]
	mov		rdx, offset sEven
	mov		r8, sizeof sEven
	mov		r9, offset nByte
	mov		[rsp + 20h], r15
	call	WriteFile						;write text "even ...."
	mov		esi, EvenSum
	call	itoa							;itoa(esi = num --> rsi = &num, rax = num.length)
	mov		word ptr [rsi + rax], 0A0Dh		;add \r\n
	add		rax, 2
	mov		rcx, [rbp - 10h]
	mov		rdx, rsi
	mov		r8, rax
	mov		r9, offset nByte
	mov		[rsp + 20h], r15
	call	WriteFile						;print sum even calculated
	;write odd
	mov		rcx, [rbp - 10h]
	mov		rdx, offset sOdd
	mov		r8, sizeof sOdd
	mov		r9, offset nByte
	mov		[rsp + 20h], r15
	call	WriteFile						;write text "odd ...."
	mov		esi, OddSum
	call	itoa							;itoa(esi = num --> rsi = &num, rax = num.length)
	mov		word ptr [rsi + rax], 0A0Dh		;add \r\n
	add		rax, 2
	mov		rcx, [rbp - 10h]
	mov		rdx, rsi
	mov		r8, rax
	mov		r9, offset nByte
	mov		[rsp + 20h], r15
	call	WriteFile						;print sum odd calculated

	mov		rcx, 0
	call	ExitProcess

main endp

atoi proc			;atoi(rsi = &string --> rax = number)
	push	rbp
	mov		rbp, rsp
	push	rbx
	push	rdx
	xor		rax, rax
	mov		rbx, 10				;rbx = 10

	@TextNum:
		xor		rdx, rdx
		mov		dl, byte ptr [rsi]			;dl = string[i]
		cmp		dl, '0'
		jl		@Exit						; < '0' --> not number
		cmp		dl, '9'
		jg		@Exit						; > '9' --> not number
		sub		dl, 30h						;string[i] - 48
		add		rax, rdx					;rax = number
		mul		rbx							;rax *= rbx
		inc		rsi
		jmp		@TextNum

	@Exit:
		xor		rdx, rdx
		div		rbx							;rax = number*10 --> rax/=10 = number 
		pop		rdx
		pop		rbx
		mov		rsp, rbp
		pop		rbp
		ret

atoi endp

itoa proc				;itoa(rsi = number --> rsi = &string number)
	push	rbp
	mov		rbp, rsp
	push	rbx
	push	rdx
	mov		rbx, rsi			;rbx = number

	sub		rsp, 20h			;Shadow Space 
	call	GetProcessHeap		;Get Handle Heap
	mov		rcx, rax			;Return value to rcx
	mov		rdx, 0
	mov		r8, 10				;Size Alloc
	call	HeapAlloc			;HeapAlloc(Handle, HEAP_ZERO_MEMORY, size)
	add		rsp, 20h			;Remove Shadow Space
	mov		rdi, rax
	add		rdi, 10				;rdi = *(str + 10)

	mov		rax, rbx			;rax = number
	mov		rsi, rdi			
	mov		rbx, 10

	@NumText:
		xor		rdx, rdx
		div		rbx				;rax = number/10
		add		dl, 30h			;dl = remain = rax/10 
		mov		byte ptr [rdi], dl			;mov dl+48 to string
		dec		rdi
		test	rax, rax
		jz		@Exit
		jmp		@NumText

	@Exit:
		sub		rsi, rdi		;rsi = length string
		mov		rax, rsi		;rax = rsi
		mov		rsi, rdi		;rsi = &string
		inc		rsi
		pop		rdx
		pop		rbx
		mov		rsp, rbp
		pop		rbp
		ret
		
itoa endp
end

