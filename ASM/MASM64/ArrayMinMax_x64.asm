extrn GetStdHandle		:PROC
extrn ReadFile			:PROC
extrn WriteFile			:PROC
extrn GetProcessHeap	:PROC
extrn HeapAlloc			:PROC
extrn HeapFree			:PROC
extrn ExitProcess		:PROC

.data
	sSize	db "Nhap kich thuoc mang = ", 0h
	sArrReq	db "Nhap tung phan tu cua mang = ", 0h
	sMin	db "Min = ", 0h
	sMax	db "Max = ", 0h

.data?
	Buffer	db 1000 dup(?)
	Arr		dd 100 dup(?)
	sArr	dd 0
	min		dd 0
	max		dd 0
	nByte	dd 0
.code
main proc
	mov		rbp, rsp
	sub		rsp, 48h				;Shadow Space + Align + 2 Local variable

	mov		rcx, -10
	call	GetStdHandle
	mov		[rbp - 08h], rax		;STD_INPUT_HANDLE
	mov		rcx, -11
	call	GetStdHandle
	mov		[rbp - 10h], rax		;STD_OUTPUT_HANDLE

	xor		r15, r15

	mov		rcx, [rbp - 10h]
	mov		rdx, offset sSize
	mov		r8, sizeof sSize
	mov		r9, offset nByte
	mov		[rsp + 20h], r15
	call	WriteFile

	mov		rcx, [rbp - 08h]
	mov		rdx, offset Buffer
	mov		r8, 10
	mov		r9, offset nByte
	mov		[rsp + 20h], r15
	call	ReadFile
	mov		rsi, offset Buffer
	call	atoi
	mov		sArr, eax						;sArr = Size array

	mov		rcx, [rbp - 10h]
	mov		rdx, offset sArrReq
	mov		r8, sizeof sArrReq
	mov		r9, offset nByte
	mov		[rsp + 20h], r15
	call	WriteFile

	xor		rbx, rbx
	@ArrRequest:
		mov		rcx, [rbp - 08h]
		mov		rdx, offset Buffer
		mov		r8, 1000
		mov		r9, offset nByte
		mov		[rsp + 20h], r15
		call	ReadFile					;read data

		mov		rsi, offset Buffer			;rsi = &buffer
		mov		r14, offset Arr				;r14 = array save

	@HandleArr:			
		push	rsi							
		call	atoi						;atoi(rsi = &string --> return rax = number)
		mov		dword ptr [r14 + rbx*4], eax		;r14 = &savearr = array save number 
		inc		rbx
		cmp		ebx, sArr
		jz		@DoneArr
		pop		rsi
	
	@NextArr:
		cmp		byte ptr [rsi], 0Dh			
		jz		@ArrRequest
		inc		rsi
		cmp		byte ptr [rsi - 1], 20h
		jz		@HandleArr
		jmp		@NextArr

	@DoneArr:
		mov		rsi, offset Arr
		mov		edi, sArr
		mov		rdx, offset min
		call	findmin
		;write min
		mov		rcx, [rbp - 10h]
		mov		rdx, offset sMin
		mov		r8, sizeof sMin
		mov		r9, offset nByte
		mov		[rsp + 20h], r15
		call	WriteFile
		mov		esi, min
		call	itoa
		mov		word ptr [rsi + rax], 0A0Dh
		add		rax, 2
		mov		rcx, [rbp - 10h]
		mov		rdx, rsi
		mov		r8, rax
		mov		r9, offset nByte
		mov		[rsp + 20h], r15
		call	WriteFile

		mov		rsi, offset Arr
		mov		edi, sArr
		mov		rdx, offset max
		call	findmax
		;write max
		mov		rcx, [rbp - 10h]
		mov		rdx, offset sMax
		mov		r8, sizeof sMax
		mov		r9, offset nByte
		mov		[rsp + 20h], r15
		call	WriteFile
		mov		esi, max
		call	itoa
		mov		word ptr [rsi + rax], 0A0Dh
		add		rax, 2
		mov		rcx, [rbp - 10h]
		mov		rdx, rsi
		mov		r8, rax
		mov		r9, offset nByte
		mov		[rsp + 20h], r15
		call	WriteFile

	xor		rcx, rcx
	call	ExitProcess

main endp

findmin proc			;findmin(rsi = $arr, edi = ArrSSize, rdx = &min ---> rdx = min)
	push	rbp
	mov		rbp, rsp
	sub		rsp, 8h
	push	rbx
	mov		[rbp - 08h], rdx
	mov		r8d, 0fffffffh
	xor		rbx, rbx

	@Compare:
		cmp		dword ptr [rsi], r8d			;check min in array
		jl		@isMin

	@NextArr:
		add		rsi, 4
		inc		rbx
		cmp		ebx, edi
		jz		@Exit
		jmp		@Compare

	@isMin:
		mov		r8d, dword ptr [rsi]
		jmp		@NextArr

	@Exit:
		mov		dword ptr [rdx], r8d
		pop		rbx
		mov		rsp, rbp
		pop		rbp
		ret		8
findmin endp

findmax proc			;findmax(rsi = $arr, edi = ArrSSize, rdx = &max ---> rdx = max)
	push	rbp
	mov		rbp, rsp
	sub		rsp, 8h
	push	rbx
	mov		[rbp - 08h], rdx
	mov		r8d, 0
	xor		rbx, rbx

	@Compare:
		cmp		dword ptr [rsi], r8d
		jg		@isMax

	@NextArr:
		add		rsi, 4
		inc		rbx
		cmp		ebx, edi
		jz		@Exit
		jmp		@Compare

	@isMax:
		mov		r8d, dword ptr [rsi]
		jmp		@NextArr

	@Exit:
		mov		dword ptr [rdx], r8d
		pop		rbx
		mov		rsp, rbp
		pop		rbp
		ret		8
findmax endp

atoi proc				;atoi(rsi = &string --> rax = number)
	push	rbp
	mov		rbp, rsp
	push	rbx
	push	rdx
	xor		rax, rax
	mov		rbx, 10

	@TextNum:
		xor		rdx, rdx
		mov		dl, byte ptr [rsi]
		cmp		dl, '0'
		jl		@Exit
		cmp		dl,'9'
		jg		@Exit
		sub		dl, 30h
		add		rax, rdx
		mul		rbx
		inc		rsi
		jmp		@TextNum

	@Exit:
		xor		rdx, rdx
		div		rbx
		pop		rdx
		pop		rbx
		mov		rsp, rbp
		pop		rbp
		ret
atoi endp

itoa proc				;itoa(rsi = number --> rsi = &string number)
	push	rbp
	mov		rbp, rsp
	push	rbx
	push	rdx
	mov		rbx, rsi

	sub		rsp, 20h
	call	GetProcessHeap
	mov		rcx, rax
	mov		rdx, 0
	mov		r8, 10
	call	HeapAlloc
	add		rsp, 20h
	mov		rdi, rax
	add		rdi, 10
	
	mov		rax, rbx
	mov		rsi, rdi
	mov		rbx, 10

	@NumText:
		xor		rdx, rdx
		div		rbx
		add		dl, 30h
		mov		byte ptr [rdi], dl
		dec		rdi
		test	rax, rax
		jz		@Exit
		jmp		@NumText

	@Exit:
		sub		rsi, rdi
		mov		rax, rsi
		mov		rsi, rdi
		inc		rsi
		pop		rdx
		pop		rbx
		mov		rsp, rbp
		pop		rbp
		ret

itoa endp
end