extrn   CloseHandle:                proc
extrn   CreateWindowExA:            proc
extrn   DefWindowProcA:             proc
extrn   DispatchMessageA:           proc
extrn   EnumWindows:                proc
extrn   ExitProcess:                proc
extrn   KillTimer:                  proc
extrn   LoadIconA:                  proc
extrn   LoadCursorA:                proc
extrn   GetDlgItemTextA:            proc
extrn   GetCommandLineA:            proc
extrn   GetMessageA:                proc
extrn   GetModuleHandleA:           proc
extrn   GetWindowThreadProcessId:   proc
extrn   GetProcessImageFileNameA:   proc
extrn   OpenProcess:                proc
extrn   PostQuitMessage:            proc
extrn   RegisterClassExA:           proc
extrn   SendMessageA:               proc
extrn   SetDlgItemTextA:            proc
extrn   SetTimer:                   proc
extrn   ShowWindow:                 proc
extrn   TranslateMessage:           proc

.data
	szClassName			db "AntiBrowsers", 0
	lpMainWindowName	db "Anti Browsers", 0
	lpClassNameStatic	db "STATIC", 0
	lpWindowNameError	db "No browsers are running anymore!", 0
	firefoxName			db "firefox.exe", 0
	chromeName			db "chrome.exe", 0
	msedgeName			db "msedge.exe", 0

.data?
	wndclass	db 80 dup(?)
	msg			db 48 dup(?)
	buffer		db 256 dup(?)
	procID		dd ?
	hProc		dq ?

.code
WinMainCRTStartup proc 
	mov		rbp, rsp
	sub		rsp, 28h

	xor		rcx, rcx
	call	GetModuleHandleA
	mov		rcx, rax
	call	GetCommandLineA
	mov		r8, rax
	mov		r9, 10
	xor		rdx, rdx
	call	WinMain

	mov		rsp, rbp
	pop		rbp
	ret

WinMainCRTStartup endp

WinMain proc
    push    rbp
    mov     rbp, rsp
    sub     rsp, 60h        
 
	mov		r13, rcx
    mov     qword ptr [wndclass + 18h], rcx			;hInstance
    mov     dword ptr [wndclass], 80				;cbSize = sizeof WNDCLASSEXA
    mov     dword ptr [wndclass + 4], 2 or 1		;style = CS_HREDRAW | CS_VREDRAW
    lea     rcx, WinProc
    mov     qword ptr [wndclass + 8], rcx			;>lpfnWndProc = WinProc    
    mov     dword ptr [wndclass + 10h], 0			;cbClsExtra = 0
    mov     dword ptr [wndclass + 14h], 0			;cbWndExtra = 0
    xor     ecx, ecx
    mov     edx, 32512								;IDI_APPLICATION standard icon ids
    call    LoadIconA
    mov     qword ptr [wndclass + 20h], rax			;hIcon = LoadIconA(NULL, IDI_APPLICATION)
    xor     ecx, ecx
    mov     edx, 32512								;IDC_ARROW standard cursor ids
    call    LoadCursorA
    mov     qword ptr [wndclass + 28h], rax			;hCursor = 
    mov     qword ptr [wndclass + 30h], 1			;hbrBackgrount = COLOR_BACKGROUND
    mov     qword ptr [wndclass + 38h], 0			;lpszMenuName = null
    mov     rcx, offset szClassName
    mov     qword ptr [wndclass + 40h], rcx			;lpszClassName = "TextReverse"
    mov     rcx, qword ptr [wndclass + 20h]
    mov     qword ptr [wndclass + 48h], rcx			;hIconSm = LoadIconA(NULL, IDI_APPLICATION)

    ; try registering class
    lea     rcx, wndclass
    call    RegisterClassExA
    test    ax, ax
    jz      exitProg

    ; once registered succeedfully create program...
	lea     rdx, szClassName     
    lea     r8, lpMainWindowName                
    mov     r9, 0cf0000h							;WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX
    mov     dword ptr [rsp + 20h], 80000000h		;CW_USEDEFAULT
    mov     dword ptr [rsp + 28h], 80000000h		;CW_USEDEFAULT
    mov     qword ptr [rsp + 30h], 300				;width
    mov     qword ptr [rsp + 38h], 100				;height
    mov     qword ptr [rsp + 40h], 0				;HWND_DESKTOP 
    mov     qword ptr [rsp + 48h], 0				;no menu
    mov     qword ptr [rsp + 50h], r13				;hInstance
    mov     qword ptr [rsp + 58h], 0				;no win creation data
    xor     rcx, rcx
    call    CreateWindowExA							;CreateWindowExA(0, szClassName, szClassName, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 300, 150, HWND_DESKTOP, NULL, hInstance, NULL)

    mov     rcx, rax
    mov     rdx, 1									;SW_NORMAL
    call    ShowWindow

    gettingMessage:
		lea     rcx, msg
		xor     rdx, rdx
		xor     r8, r8
		xor     r9, r9
		call    GetMessageA
		test    rax, rax        
		jz      exitProg							;PostQuitMessage(0)

		lea     rcx, msg
		call    TranslateMessage    
		lea     rcx, msg
		call    DispatchMessageA
		jmp     gettingMessage  

    exitProg:
		mov     rcx, rax
		call    ExitProcess

WinMain endp	

WinProc proc
	push	rbp
	mov		rbp, rsp
	sub		rsp, 60h
	mov		[rbp + 10h], rcx			;hwnd
	mov		[rbp + 18h], rdx			;msg
	mov		[rbp + 20h], r8				;wParam
	mov		[rbp + 28h], r9				;lParam
	mov		rax, rdx

	dec		rax
	jz		WM_CREATE					;WM_CREATE = 1
	dec		rax
	jz		WM_DESTROY					;WM_DESTROY = 2
	sub		rax, 111h
	jz		WM_TIMER					;WM_TIMER = 113h

	mov		rcx, [rbp + 10h]
	mov		rdx, [rbp + 18h]
	mov		r8, [rbp + 20h]
	mov		r9, [rbp + 28h]
	call	DefWindowProcA			;DefWindowProcA(hwnd, message, wParam, lParam)
	jmp		exitProc

	WM_CREATE:
		xor		rcx, rcx
		mov		rdx, offset lpClassNameStatic
		mov		r8, offset lpWindowNameError
		mov		r9, 50000000h							;WS_CHILD | WS_VISIBLE
		mov		qword ptr [rsp + 20h], 80000000h		;CW_USEDEFAULT
		mov		qword ptr [rsp + 28h], 80000000h		;CW_USEDEFAULT
		mov		qword ptr [rsp + 30h], 500				;width = 500
		mov		qword ptr [rsp + 38h], 200				;height = 30
		mov		rax, [rbp + 10h]
		mov		qword ptr [rsp + 40h], rax		;hwnd
		mov		qword ptr [rsp + 48h], 1		;set hMenu = 1
		mov		qword ptr [rsp + 50h], 0
		mov		qword ptr [rsp + 58h], 0
		call	CreateWindowExA

		mov		rcx, offset nextWindow
		xor		rdx, rdx
		call	EnumWindows
		mov		rcx, [rbp + 10h]			;hwnd
		mov		rdx, 1
		mov		r8, 5000
		mov		r9, 0
		call	SetTimer					;set a timer every 5 seconds
		jmp		exitProc

	WM_DESTROY:
		mov		rcx, [rbp + 10h]
		mov		rdx, 1
		call	KillTimer					;kill timer and request to quit
		xor		rcx, rcx
		call	PostQuitMessage
		jmp		exitProc

	WM_TIMER:
		mov		rcx, offset nextWindow
		xor		rdx, rdx
		call	EnumWindows					;enum each 5 seconds
	
	exitProc:
		mov		rsp, rbp
		pop		rbp
		ret

WinProc endp

nextWindow proc
	push	rbp
	mov		rbp, rsp
	push	rbx
	sub		rsp, 20h
	mov		[rbp + 10h], rcx			;hwnd
	mov		[rbp + 18h], rdx			;lparam

	cmp		rcx, 0
	jz		exitProc

;	mov		rcx, [rbp + 10h]
	mov		rdx, offset procID
	call	GetWindowThreadProcessId			;get hProc from hwnd
	mov		rcx, 400h
	mov		rdx, 0
	mov		r8d, procID
	call	OpenProcess							;open process to retrieve information
	mov		hProc, rax
	mov		rcx, hProc
	mov		rdx, offset buffer
	mov		r8, 255
	call	GetProcessImageFileNameA			;get process executable file name (full path)
	;get only filename
	;find strlen filename
	mov		rcx, offset buffer				;full path
	call	strlen
	mov		rsi, offset buffer
	add		rsi, rax						;end of filename
	std										;set DF
	loopSym:
		lodsb
		cmp		al, '\'
		jz		cmpBrowserName
		jmp		loopSym

	cmpBrowserName:
		mov		rax, offset buffer
		sub		rsi, rax
		mov		rax, rsi					;rsi -> len(buffer) = filename
		add		rax, 2						;start filename
		mov		rbx, rax
		;finding brownsers name --> kill
		mov		rcx, offset buffer
		add		rcx, rbx
		mov		rdx, offset firefoxName
		mov		r8, 12
		call	strncmp
		cmp		rax, 0
		jz		KillBrowsers

		mov		rcx, offset buffer
		add		rcx, rbx
		mov		rdx, offset chromeName
		mov		r8, 11
		call	strncmp
		cmp		rax, 0
		jz		KillBrowsers

		lea     rcx, buffer
		add     rcx, rbx
		lea     rdx, msedgeName
		mov     r8, 11
		call    strncmp
		test    rax, rax
		jz      KillBrowsers
		jmp     exitProc

	KillBrowsers:
		mov		rcx, [rbp + 10h]			;hwnd
		mov		rdx, 2						;WM_DESTROY
		mov		r8, 0
		mov		r9, 0
		call	SendMessageA

	exitProc:
		mov		rcx, hProc
		call	CloseHandle
		mov		rax, 1
		add		rsp, 20h
		pop		rbx
		mov		rsp, rbp
		pop		rbp
		ret

nextWindow endp

strlen proc
	push	rbp
	mov		rbp, rsp
	push	rsi
	mov		rsi, rcx			;buffer
	xor		rax, rax
	cld

	loopSym:
		lodsb
		cmp		rax, 0
		jz		exit
		jmp		loopSym

	exit:
		sub		rsi, rcx
		mov		rax, rsi			;rax = len(buffer)
		dec		rax
		pop		rsi
		mov		rsp, rbp
		pop		rbp
		ret

strlen endp

strncmp proc
	push	rbp
	mov		rbp, rsp
	push	rsi
	push	rdi
	mov		rsi, rcx				;buffer
	mov		rdi, rdx				;filename
	xor		rax, rax
	cld
	mov		rcx, r8					;len filename
	loopSym:
		lodsb
		cmp		al, byte ptr [rdi]
		jnz		exit
		inc		rdi
		dec		rcx
		cmp		rcx, 0
		jnz		loopSym
	
	result:
		mov		rax, 0
		pop		rdi
		pop		rsi
		mov		rsp, rbp
		pop		rbp
		ret

	exit:
		mov		rax, rcx
		pop		rdi
		pop		rsi
		mov		rsp, rbp
		pop		rbp
		ret

strncmp endp
end