extrn   CreateSolidBrush:   proc
extrn   CreateWindowExA:    proc
extrn   DefWindowProcA:     proc
extrn   DispatchMessageA:   proc
extrn   Ellipse:            proc
extrn   ExitProcess:        proc
extrn   FillRect:           proc
extrn   LoadIconA:          proc
extrn   LoadCursorA:        proc
extrn   KillTimer:          proc
extrn   GetClientRect:      proc
extrn   GetCommandLineA:    proc
extrn   GetDC:              proc
extrn   GetLocalTime:       proc
extrn   GetMessageA:        proc
extrn   GetModuleHandleA:   proc
extrn   GetStockObject:     proc
extrn   PostQuitMessage:    proc
extrn   RegisterClassExA:   proc
extrn   ReleaseDC:          proc
extrn   SelectObject:       proc
extrn   SetTimer:           proc
extrn   ShowWindow:         proc
extrn   TranslateMessage:   proc

.data
    szClassName         db  "BoucingBall", 0
    lpMainWindowName    db  "Boucing Ball", 0
.data?
    wndclass    db  80  dup(?)      ;WndClassExA struct
    msg         db  48  dup(?)      ;msg struct
    hdc         dq  ?               ;HDC = handle to a divice context
    hwnd        dq  ?    
    lpTime      db  16  dup(?)      ;SystemTime struct
    rect        db  16  dup(?)      ;RECT struct
    tmpRect     db  16  dup(?)      ;Rect struct
    hWhiteBrush dq  ?
    hRedBrush   dq  ?
    ;direction of the ball
    xDir        dd  ?
    yDir        dd  ?
    ;current position of the ball
    x           dd  ?
    y           dd  ?
    ;old position of the ball
    xOld        dd  ?
    yOld        dd  ?
.code
WinMainCRTStartup proc
    mov     rbp, rsp
    sub     rsp, 28h

    xor     rcx, rcx
    call    GetModuleHandleA
    mov     rcx, rax                ;rcx = hInstance
    call    GetCommandLineA         
    mov     r8, rax                 ;r8 = szCmdLine
    mov     r9, 10                  
    xor     rdx, rdx
    call    WinMain

    mov     rsp, rbp
    pop     rbp
    ret
WinMainCRTStartup endp

WinMain proc
    push    rbp
    mov     rbp, rsp
    sub     rsp, 60h
    ;WndClassExA
    mov     r13, rcx                                ;hInstance
    mov     qword ptr [wndclass + 18h], rcx         ;hInstance
    mov     dword ptr [wndclass], 80                ;cbSize = sizeof WndClassExA
    mov     dword ptr [wndclass + 4], 2 or 1        ;style = CS_HREDRAW | CS_VREDRAW
    lea     rcx, WinProc
    mov     qword ptr [wndclass + 8], rcx           ;lpfnWndProc = WinProc
    mov     dword ptr [wndclass + 10h], 0           ;cbClsExtra = 0
    mov     dword ptr [wndclass + 14h], 0           ;cbWndExtra = 0
    xor     rcx, rcx
    mov     rdx, 32512                              ;IDI_APPLICATION = Default application icon
    call    LoadIconA
    mov     qword ptr [wndclass + 20h], rax         ;hIcon = LoadIconA(NULL, IDI_APPLICATION)
    mov     qword ptr [wndclass + 48h], rax         ;hIconSm = LoadIconA(NULL, IDI_APPLICATION)
    xor     rcx, rcx    
    mov     rdx, 32512                              ;IDC_ARROW aka standard cursor ids
    call    LoadCursorA
    mov     qword ptr [wndclass + 28h], rax         ;hCursor = LoadCursorA(NULL, IDI_APPLICATION)
    mov     rcx, 0ffh
    call    CreateSolidBrush
    mov     hRedBrush, rax
    xor     rcx, rcx
    call    GetStockObject
    mov     hWhiteBrush, rax
    mov     qword ptr [wndclass + 30h], rax         ;hbrBackground = GetStockObject(WHITE_BRUSH)
    mov     qword ptr [wndclass + 38h], 0           ;lpszMenuName = null
    lea     rcx, szClassName
    mov     qword ptr [wndclass + 40h], rcx         ;lpszClassName

    lea     rcx, wndclass
    call    RegisterClassExA
    cmp     ax, 0
    jz      exitProg

    xor     rcx, rcx                                ;dwExStyle
    lea     rdx, szClassName
    lea     r8, lpMainWindowName
    mov     r9, 0cf0000h                            ;WS_OVERLAPPEDWINDOW
    mov     dword ptr [rsp + 20h], 80000000h        ;CW_USEDEFAULT
    mov     dword ptr [rsp + 28h], 80000000h        ;CW_USEDEFAULT
    mov     qword ptr [rsp + 30h], 500              ;width
    mov     qword ptr [rsp + 38h], 400              ;height
    mov     qword ptr [rsp + 40h], 0                ;HWND_DESKTOP -> child window to desktop
    mov     qword ptr [rsp + 48h], 0                ;no menu
    mov     qword ptr [rsp + 50h], r13              ;hInstance
    mov     qword ptr [rsp + 58h], 0                ;no additional data
    call    CreateWindowExA
    mov     hwnd, rax

    mov     rcx, rax
    mov     rdx, 1
    call    ShowWindow

    getMessage:
        lea     rcx, msg
        xor     rdx, rdx
        xor     r8, r8
        xor     r9, r9
        call    GetMessageA
        cmp     rax, 0              ;if returns 0 --> PostQuitMessage(0)
        jz      exitProg
        ;translate virtual key msg into character msg
        lea     rcx, msg
        call    TranslateMessage
        lea     rcx, msg
        call    DispatchMessageA
        jmp     getMessage

    exitProg:
        mov     rcx, rax
        call    ExitProcess

WinMain endp

WinProc proc
    push    rbp
    mov     rbp, rsp
    push    rbx
    sub     rsp, 38h
    mov     [rbp + 10h], rcx        ;hwnd
    mov     [rbp + 18h], rdx        ;msg
    mov     [rbp + 20h], r8         ;wparam
    mov     [rbp + 28h], r9         ;lparam

    mov     rax, rdx
    dec     rax
    jz      WM_CREATE       ;WM_CREATE = 1
    dec     rax
    jz      WM_DESTROY      ;WM_DESTROY = 2
    sub     rax, 111h       
    jz      WM_TIMER        ;WM_COMMAND = 113h
    sub     rax, 101h       
    jz      WM_SIZING       ;WM_SIZING = 214h
    ;default --> return DefWindowProcA
    mov     rcx, [rbp + 10h]
    mov     rdx, [rbp + 18h]
    mov     r8, [rbp + 20h]
    mov     r9, [rbp + 28h]
    call    DefWindowProcA  ; DefWindowProcA(hwnd, message, wParam, lParam)
    jmp     exitProc

    WM_CREATE:
        lea     rcx, lpTime
        call    GetLocalTime
        mov     bx, word ptr [lpTime + 0Ch]             ;lpTime->wSecond
        and     bx, 3
        jz      rightUp                                 ;bx = 0
        dec     bx
        jz      leftUp                                  ;bx = 1
        dec     bx
        jz      rightDown                               ;bx = 2
        jmp     leftDown 
        
        rightUp:
            mov     xDir, 5
            mov     yDir, 5
            jmp     setLocation
        leftUp:
            mov     xDir, -5
            mov     yDir, 5
            jmp     setLocation
        rightDown:
            mov     xDir, 5
            mov     yDir, -5
            jmp     setLocation
        leftDown:
            mov     xDir, -5
            mov     yDir, -5
        setLocation:                        ;set the ball at middle of window
            mov     rcx, [rbp + 10h]
            lea     rdx, rect
            call    GetClientRect
            mov     eax, dword ptr [rect + 8]           ;rect->right
            shr     eax, 1                                   ;>> 1 (equal /2)
            sub     eax, 10                             ;rBall = 10
            mov     x, eax
            mov     eax, dword ptr [rect + 0ch]         ;rect->bottom
            shr     eax, 1                              ;>> 1 (equal /2)
            sub     eax, 10                            ;rBall = 10
            mov     y, eax

        mov     rcx, qword ptr [rbp + 10h]      
        mov     rdx, 1
        mov     r8, 1                           ; every 0.001 seconds
        mov     r9, 0
        call    SetTimer
        jmp     exitProc

    WM_DESTROY:
        mov     rcx, [rbp + 10h]
        mov     rdx, 1
        call    KillTimer
        mov     rcx, 0
        call    PostQuitMessage
        jmp     exitProc

    WM_TIMER:
        mov     rcx, [rbp + 10h]
        call    GetDC
        mov     hdc, rax
        mov     rcx, hdc
        mov     rdx, hWhiteBrush
        call    SelectObject
        mov     rbx, rax                            ;rbx = save brush

        mov     eax, xOld
        mov     dword ptr [tmpRect], eax            ;tmpRect.left = oldX
        add     eax, 20
        mov     dword ptr [tmpRect + 8], eax        ;tmpRect.right = oldX + 20
        mov     eax, yOld
        mov     dword ptr [tmpRect + 4], eax        ;tmpRect.top = oldY
        add     eax, 20
        mov     dword ptr [tmpRect + 0Ch], eax      ;tmpRect.bot = oldY + 20
        mov     rcx, hdc
        lea     rdx, tmpRect
        mov     r8, rbx
        call    FillRect                            ;erase the old ball

        mov     rcx, hdc
        mov     rdx, hRedBrush
        call    SelectObject
        mov     rcx, hdc
        mov     edx, x
        mov     r8d, y
        mov     r9d, x
        add     r9d, 20
        mov     r12d, y
        add     r12d, 20
        mov     [rsp + 20h], r12d
        call    Ellipse                         ;Ellipse(hdc, x, y, 20 + x, 20 + y)
        mov     eax, x
        mov     xOld, eax
        mov     eax, y
        mov     yOld, eax

        mov     ebx, -1
        mov     eax, x
        add     eax, xDir
        cmp     eax, 0                              ;x + xDir < 0
        jl      RevX        
        add     eax, 20
        cmp     eax, dword ptr [rect + 8]               ;x +xDir + 20 > rect.right
        jg      RevX

        checkY:
            mov     eax, y
            add     eax, yDir
            cmp     eax, 0                              ;y + yDir < 0
            jl      RevY       
            add     eax, 20
            cmp     eax, dword ptr [rect + 0Ch]               ;y + yDir + 20 > rect.bot
            jg      RevY
            jmp     updateCoordinates
        RevX:
            mov     eax, xDir
            imul    ebx
            mov     xDir, eax
            jmp     checkY
        RevY:
            mov     eax, yDir
            imul    ebx
            mov     yDir, eax
        updateCoordinates:
            mov     eax, x
            add     eax, xDir
            mov     x, eax
            mov     eax, y
            add     eax, yDir
            mov     y, eax

        mov     rcx, [rbp + 10h]
        mov     rdx, hdc
        call    ReleaseDC
        jmp     exitProc

    WM_SIZING:
        mov     rcx, [rbp + 10h]
        lea     rdx, rect
        call    GetClientRect
        ;if the ball is outside the window, put it back
        checkEdge:
            mov     eax, x
            cmp     eax, 0
            jl      putLeftEdge
            add     eax, 20
            cmp     eax, dword ptr [rect + 8]
            jg      putRightEdge
            mov     eax, y
            cmp     eax, 0
            jl      putTopEdge
            add     eax, 20
            cmp     eax, dword ptr [rect + 0ch]
            jg      putBottomEdge
            jmp     exitProc
        putLeftEdge:
            xor     eax, eax
            mov     x, eax
            jmp     checkEdge
        putRightEdge:
            mov     eax, dword ptr [rect + 8]
            sub     eax, 20
            mov     x, eax
            jmp     checkEdge
        putTopEdge:
            xor     eax, eax
            mov     y, eax
            jmp     checkEdge
        putBottomEdge:
            mov     eax, dword ptr [rect + 0ch]
            sub     eax, 20
            mov     x, eax
            jmp     checkEdge

    exitProc:
        add     rsp, 38h
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret

WinProc endp
end