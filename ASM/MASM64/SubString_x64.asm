extrn GetStdHandle		:PROC
extrn ReadFile			:PROC
extrn WriteFile			:PROC
extrn ExitProcess		:PROC
extrn GetProcessHeap	:PROC
extrn HeapAlloc			:PROC

.data
	sTextCha	db "S = ", 0h
	sTextCon	db "C = ", 0h

.data?
	sCha		db 100 dup(?)
	sCon		db 10 dup(?)
	SaveIndex	db 100 dup(?)
	nByte		dd 0

.code
main proc
	mov		rbp, rsp
	sub		rsp, 38h			;Shadow Space + Align + Local variable

	mov		rcx, -10
	call	GetStdHandle
	mov		[rbp - 08h], rax	;STD_INPUT_HANDLE
	mov		rcx, -11
	call	GetStdHandle
	mov		[rbp - 10h], rax	;STD_OUTPUT_HANDLE

	xor		r14, r14
	xor		r13, r13			;SaveIndex [r13] = array save index found

	mov		rcx, [rbp - 10h]
	mov		rdx, offset sTextCha
	mov		r8, sizeof sTextCha
	mov		r9, offset nByte
	mov		[rsp + 20h], r14
	call	WriteFile				;write text s = ....

	mov		rcx, [rbp - 08h]
	mov		rdx, offset sCha
	mov		r8, 100
	mov		r9, offset nByte
	mov		[rsp + 20h], r14
	call	ReadFile				;read text cha

	mov		rcx, [rbp - 10h]
	mov		rdx, offset sTextCon
	mov		r8, sizeof sTextCon
	mov		r9, offset nByte
	mov		[rsp + 20h], r14
	call	WriteFile				;write text c = ....

	mov		rcx, [rbp - 08h]
	mov		rdx, offset sCon
	mov		r8, 10
	mov		r9, offset nByte
	mov		[rsp + 20h], r14
	call	ReadFile				;read text con

	mov		rsi, offset sCon
	call	sLength				;;sLength(rsi = &string	--> return rax = &string.length)
	mov		r15, rax			;r15 = sCon.length

	mov		rsi, offset sCha
	mov		rdi, offset sCon
	call	find				;find(rsi = &sCha, rdi = &sCon)

	mov		rsi, r12
	call	itoa
	mov		r11w, 0A0Dh							;insert \r\n
	mov		word ptr [rsi + rax], r11w
	add		rax, 2
	mov		rcx, [rbp - 10h]
	mov		rdx, rsi
	mov		r8, rax
	mov		r9, offset nByte
	mov		[rsp + 20h], r14
	call	WriteFile							;write count index found

	mov		rcx, [rbp - 10h]
	mov		rdx, offset SaveIndex
	mov		r8, r13
	mov		r9, offset nByte
	mov		[rsp + 20h], r14
	call	WriteFile							;write array SaveIndex found

	xor		rcx, rcx
	call	ExitProcess


main endp

find proc				;find(rsi = &sCha, rdi = &sCon	--> )
	push	rbp
	mov		rbp, rsp
	push	rax
	push	rbx
	xor		rax, rax
	xor		rbx, rbx
	mov		rax, rsi			;rax = rsi = &sCha
	mov		rbx, rdi			;rbx = rdi = &sCon
	xor		rsi, rsi

	@FirstSym:
		xor		rdx, rdx
		xor		rdi, rdi
		mov		dl, byte ptr [rax + rsi]				;cmp ki tu cua xau Cha so voi ki tu dau xau Con
		mov		dh, byte ptr [rbx + 0h]
		cmp		dl,	0Dh		
		jz		@Exit
		cmp		dl, dh
		jz		@FindString								;Cha[i] == Con[0] --> jmp
		inc		rsi
		jmp		@FirstSym

	@FindString:
		xor		rdx, rdx
		mov		dl, byte ptr [rbx + rdi]				;dl = (char)con
		cmp		dl, 0Dh									;dl == \r
		jz		@PrintNum								;(string)con end --> print number found
		mov		dh, byte ptr [rax + rsi]				;dh = (char)cha
		cmp		dh, dl									
		jnz		@FirstSym								;Cha[i] != Con[0] --> jmp find again
		inc		rsi
		inc		rdi
		jmp		@FindString

	@PrintNum:
		push	rsi										;push count xau Cha
		push	rax										;push &sCha
		sub		rsi, r15
		call	itoa									;return rsi = &num
		mov		r11w, 0A0Dh
		mov		word ptr [rsi + rax], r11w
		add		rax, 2
		pop		rax										;return &sCha
		mov		rdi, offset SaveIndex					;rdi = &SaveIndex array
		call	save									;save(rsi = &index, rdi = &SaveIndex --> r13 = Count Index)
		pop		rsi										;return count xau Cha
		sub		rsi, r15
		add		rsi, 1
		inc		r12				;count index
		jmp		@FirstSym

	@Exit:
		pop		rbx
		pop		rax
		mov		rsp, rbp
		pop		rbp
		ret

find endp

save proc			;save(rsi = &index, rdi = &SaveIndex --> r13 = Count Index)
	push	rbp
	mov		rbp, rsp
	push	rbx
	push	rdx
	mov		rbx, rdi			;rbx = &SaveIndex

	@Forward:
		xor		rdx, rdx
		mov		dl, byte ptr [rsi]			;dl = (char)index
		cmp		dl, 0Dh						
		jz		@Exit						;dl = \r
		mov		byte ptr [rbx + r13], dl	;mov (char)index to array save index)
		inc		rsi
		inc		r13
		jmp		@Forward

	@Exit:
		xor		rdx, rdx
		mov		byte ptr [rbx + r13], 20h		;mov space to array
		inc		r13								;++array
		pop		rdx
		pop		rbx
		mov		rsp, rbp
		pop		rbp
		ret

save endp

sLength proc			;sLength(rsi = &string	--> return rax = &string.length)
	push	rbp
	mov		rbp, rsp
	push	rbx
	push	rdx
	mov		rbx, rsi				;&String
	xor		rax, rax
	
	@Loop:
		xor		rdx, rdx
		mov		dl, byte ptr [rbx]		;dl = (char)string
		cmp		dl, 0Dh					
		jz		@Exit					;dl = \r --> exit
		inc		rbx
		inc		rax
		jmp		@Loop

	@Exit:
		xor		rdx, rdx
		pop		rdx
		pop		rbx
		mov		rsp, rbp
		pop		rbp
		ret

sLength endp

itoa proc			;itoa(rsi = num	--> rax = &num.length, rsi = &num)
	push	rbp
	mov		rbp, rsp
	push	rbx
	push	rdx
	mov		rbx, rsi

	sub		rsp, 20h			;Shadow Space
	call	GetProcessHeap
	mov		rcx, rax			;Return Value
	mov		rdx, 0
	mov		r8, 21				;Size Alloc
	call	HeapAlloc			;HeapAlloc(Handle, HEAP_ZERO_MEMORY, size)
	add		rsp, 20h			;Remove Shadow Space
	mov		rdi, rax			
	add		rdi, 20				;*(str + 20)
	mov		rax, rbx			;rax = (int)num
	mov		rsi, rdi
	mov		rbx, 10

	@NumText:
		xor		rdx, rdx
		div		rbx				;rax = num/10
		add		dl, 30h			;dl = remain --> (int)remain + '0'
		mov		byte ptr [rdi], dl			;mov (char)num to string
		dec		rdi
		test	rax, rax
		jz		@Exit
		jmp		@NumText

	@Exit:
		sub		rsi, rdi		
		mov		rax, rsi		;rax = &num.length
		mov		rsi, rdi		;rsi = &num
		inc		rsi
		pop		rdx
		pop		rbx
		mov		rsp, rbp
		pop		rbp
		ret

itoa endp
end