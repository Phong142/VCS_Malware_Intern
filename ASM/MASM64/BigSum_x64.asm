extrn GetStdHandle	:PROC
extrn ReadFile		:PROC
extrn WriteFile		:PROC
extrn ExitProcess	:PROC

.data
	sNum1		db "Num1 = ", 0h
	sNum2		db "Num2 = ", 0h
	sResult		db "Result = ", 0h

.data?
	Num1	db 30 dup(?)
	Num2	db 30 dup(?)
	Num1Fix	db 30 dup(?)
	Num2Fix	db 30 dup(?)
	Result	db 31 dup(?)
	nByte	dd 0

.code
main proc
	mov		rbp, rsp
	sub		rsp, 38h							;shadow space + align + 2 local variable

	mov		rcx, -10
	call	GetStdHandle
	mov		[rbp - 08h], rax					;STD_INPUT_HANDLE
	mov		rcx, -11
	call	GetStdHandle
	mov		[rbp - 10h], rax					;STD_OUtPUT_HANDLE

	xor		r15, r15
	
	input1:
		mov		rcx, [rbp -10h]
		mov		rdx, offset sNum1
		mov		r8, sizeof sNum1
		mov		r9, offset nByte
		mov		[rsp + 20h], r15
		call	WriteFile						;write text Num1

		mov		rcx, [rbp - 08h]
		mov		rdx, offset Num1
		mov		r8, 30
		mov		r9, offset nByte
		mov		[rsp + 20h], r15
		call	ReadFile						;Read Num1
		mov		al, byte ptr [Num1]
		cmp		al, '-'							;if negative number --> retype
		jz		input1

	input2:
		mov		rcx, [rbp - 10h]
		mov		rdx, offset sNum2
		mov		r8, sizeof sNum2
		mov		r9, offset nByte
		mov		[rsp + 20h], r15
		call	WriteFile						;write text Num2

		mov		rcx, [rbp - 08h]
		mov		rdx, offset Num2
		mov		r8, 30
		mov		r9, offset nByte
		mov		[rsp + 20h], r15
		call	ReadFile						;Read Num2
		mov		al, byte ptr [Num2]
		cmp		al, '-'							;if negative number --> retype
		jz		input2
	
	mov		rsi, offset Num1
	mov		rdi, offset Num1Fix
	call	fixnotnumber							
	mov		rsi, offset Num2
	mov		rdi, offset Num2Fix
	call	fixnotnumber							;fixnotnumber(rsi = &Num, rdi = &numfix --> return numfix = full number)
		
	mov		rsi, offset Num1Fix
	mov		rdi, offset Num2Fix
	mov		rdx, offset Result
	call	bigsum								;bigsum (rsi = &num1, rdi = &num2, rdx = &result	--> rsi = result.length)	

	mov		rcx, [rbp - 10h]
	mov		rdx, offset sResult
	mov		r8, sizeof sResult
	mov		r9, offset nByte
	mov		[rsp + 20h], r15
	call	WriteFile							;print text the result

	cmp		rsi, 0
	jz		resultiszero

	printresult:
		mov		rcx, [rbp - 10h]
		mov		rdx, offset Result
		mov		r8, rsi
		mov		r9, offset nByte
		mov		[rbp + 20h], r15
		call	WriteFile							;print the result
		jmp		exit
	
	resultiszero:
		mov		rdi, offset Result
		mov		byte ptr [rdi + rsi], '0'
		inc		rsi
		mov		word ptr [rdi + rsi], 0A0Dh
		add		rsi, 2
		jmp		printresult

	exit:
		xor		rcx, rcx
		call	ExitProcess

main endp

fixnotnumber proc			;fixnotnumber(rsi = &Num, rdi = &numfix --> return numfix = full number)
	push	rbp
	mov		rbp, rsp
	push	rdx				
	
	loopSym:
		xor		rdx, rdx
		mov		dl, byte ptr [rsi]
		cmp		dl, 0Dh					;[num] = 0Dh --> done --> exit
		jz		exit
		cmp		dl, '0'					;[num] < '0' --> continue
		jl		continue
		cmp		dl, '9'					;[num] > '9' --> continue
		jg		continue
		mov		byte ptr [rdi], dl		;[numfix] = [num]
		inc		rsi
		inc		rdi
		jmp		loopSym

	continue:
		inc		rsi
		jmp		loopSym

	exit:
		mov		word ptr [rdi], 0A0Dh		;add \r\n to string
		add		rdi, 2
		pop		rdx
		mov		rsp, rbp
		pop		rbp
		ret
		
fixnotnumber endp

bigsum proc							;bigsum (rsi = &num1, rdi = &num 2, rdx = &result	--> rsi = result.length)
	push	rbp
	mov		rbp, rsp
	sub		rsp, 18h
	push	rax
	push	rbx
	push	rcx
	mov		[rbp - 08h], rsi				;Num1
	mov		[rbp - 10h], rdi				;Num2
	mov		[rbp - 18h], rdx				;Results
	call	reverse							;revere(num1)
	mov		rax, rsi						;rax = num1.length
	mov		rsi, [rbp - 10h]
	call	reverse
	mov		rbx, rsi						;rbx = num2.length

	cmp		rax, rbx
	jz		@Format
	jl		@Num2Max						;Num1.length < Num2.length
	jg		@Num1Max						;Num1.length > Num2.length

	@Num1Max:
		mov		rsi, [rbp - 10h]			;Num2
		push	rbx							;Num2.length (min)
		push	rax							;Num1.length (max)
		call	insertzero
		jmp		@Format

	@Num2Max:	
		mov		rsi, [rbp - 08h]			;num1
		push	rax							;Num1.length (min)
		push	rbx							;Num2.length (max)
 		call	insertzero

	@Format:
		xor		rbx, rbx
		mov		rsi, [rbp - 08h]			;Num1
		mov		rdi, [rbp - 10h]			;Num2
		mov		rdx, [rbp - 18h]			;Result
		xor		r12, r12

	@Calc:
		xor		rax, rax
		mov		al, byte ptr [rsi + rbx]	;al = [num1 + rbx]
		cmp		al, 0Dh						;[num1 + rbx] = \r --> insert mem
		jz		@InsertByteMem
		mov		ah, byte ptr [rdi + rbx]	;ah = [num2 + rbx]
		sub		al, 30h						;al - 48
		sub		ah, 30h						;ah - 48
		add		al, ah						;al + ah
		xor		ah, ah			
		add		rax, r12					;add mem 
		xor		r12, r12					;mem = 0
		cmp		al, 10						;al > 10 --> jmp
		jnc		@High						;al > 10	--> jmp

	@Next:
		add		al, 30h						;al + 48
		mov		byte ptr [rdx + rbx], al
		inc		rbx
		jmp		@Calc

	@High:
		mov		r12, 1						;add mem
		sub		al, 10						;al > 10 --> sub al, 10 --> mem = 1
		jmp		@Next

	@InsertByteMem:							;final number > 10	--> add mem
		xor		rax, rax
		mov		rax, r12					;rax = mem
		cmp		rax, 0
		je		@Exit						;rax = 0 --> mem = 0 --> exit
		add		al, 30h						
		mov		byte ptr [rdx + rbx], al	;add mem to result
		inc		rbx

	@Exit:
		mov		word ptr [rdx + rbx], 0A0Dh			;\r\n
		add		rbx, 2
		mov		r14, rbx							;Result.length
		mov		rsi, [rbp - 18h]
		call	reverse						;reverse(rsi = &num	 --> rdi = &num.reverse, rax = &num.length)
		pop		rcx
		pop		rbx
		pop		rax
		mov		rsp, rbp
		pop		rbp
		ret

bigsum endp

insertzero proc					;insertzero(rsi = &num, rax, rbx	--> rax = rbx (length 2 number))
	push	rbp
	mov		rbp, rsp
	push	rcx
	push	rdx
	mov		rcx, [rbp + 18h]				;Num2.length (min)
	mov		rdx, [rbp + 10h]				;Num1.length (max)

	@Insert:
		cmp		rcx, rdx
		jz		@Exit
		mov		byte ptr [rsi + rcx], 30h		;insert '0'
		inc		rcx
		jmp		@Insert

	@Exit:
		mov		word ptr [rsi + rcx], 0A0Dh		;add \r\n to string
		add		rcx, 2
		pop		rdx
		pop		rcx
		mov		rsp, rbp
		pop		rbp
		ret		16

insertzero endp

reverse proc			;reverse(rsi = &num	 --> rdi = &num.reverse, rax = &num.length)
	push	rbp
	mov		rbp, rsp
	push	rax
	push	rcx
	push	rdx
	mov		rdi, rsi				;save rdi = &num
	mov		rdx, rsi				;save rdx = &num
	xor		rax, rax				;rax = 0
	xor		rcx, rcx
	cld

	@PushSym:	
		lodsb						;al = [rsi++]
		cmp		al, 0Dh
		jz		@PopSym
		push	rax					;push [rax] to stack
		inc		rcx
		jmp		@PushSym

	@PopSym:
		test	rcx, rcx
		jz		@Exit
		xor		rax, rax
		pop		rax
		stosb						;[rsi++] = al
		dec		rcx
		jmp		@PopSym

	@Exit:
		sub		rdi, rdx				;rdi = num.length
		mov		rsi, rdi				;rsi = rdi
		pop		rdx
		pop		rcx
		pop		rax
		mov		rsp, rbp
		pop		rbp
		ret



reverse endp
end