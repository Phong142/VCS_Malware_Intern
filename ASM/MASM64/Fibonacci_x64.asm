extrn GetStdHandle		:PROC
extrn ReadFile			:PROC
extrn WriteFile			:PROC
extrn GetProcessHeap	:PROC
extrn HeapAlloc			:PROC
extrn ExitProcess		:PROC

.data
	sInput	db "Input = ", 0h
	sZero	db "0", 0Ah, 0h
	sOne	db "1", 0Ah, 0h
	Space	db 0Ah, 0h

.data?
	Num		db 5 dup(?)
	Num1	db 50 dup(?)
	Num2	db 50 dup(?)
	Result	db 51 dup(?)
	nByte	dd 0

.code
main proc
	mov		rbp, rsp
	sub		rsp, 38h				

	mov		rcx, -10
	call	GetStdHandle
	mov		[rbp - 08h], rax			;STD_INPUT_HANDLE
	mov		rcx, -11
	call	GetStdHandle
	mov		[rbp - 10h], rax			;STD_OUTPUT_HANDLE

	xor		r15, r15

	mov		rcx, [rbp - 10h]
	mov		rdx, offset sInput
	mov		r8, sizeof sInput
	mov		r9, offset nByte
	mov		[rsp + 20h], r15
	call	WriteFile					;write text input

	mov		rcx, [rbp - 08h]
	mov		rdx, offset Num
	mov		r8, 5
	mov		r9, offset nByte
	mov		[rsp + 20h], r15
	call	ReadFile					;read input = number of numbers

	mov		rsi, offset Num
	call	atoi						;atoi (rsi = &num --> return rax = number)
	mov		r13, rax					;r13 = (int)num

	cmp		r13, 0					
	jz		@PrintOne					;if num = 0 --> print '1'
	cmp		r13, 1					
	jz		@PrintOne					;if num = 1 --> print '1'


	@PrintZero:									;print(0)
		mov		rcx, [rbp - 10h]
		mov		rdx, offset sZero
		mov		r8, sizeof sZero
		mov		r9, offset nByte
		mov		[rsp + 20h], r15
		call	WriteFile						;print 0
		dec		r13								;number of numbers --

	@PrintOne:									;print(1)
		mov		rcx, [rbp - 10h]
		mov		rdx, offset sOne
		mov		r8, sizeof sOne
		mov		r9, offset nByte
		mov		[rsp + 20h], r15
		call	WriteFile
		cmp		r13, 0							;if r13 = 0 --> out of numbers --> exit
		jz		@Exit
		dec		r13								;number of numbers --
	
	@InsertZeroOne:								;mov num1 = 0, num2 = 1
		mov		rsi, offset Num1
		mov		byte ptr [rsi], 30h				;num1 = 0
		inc		rsi
		mov		word ptr [rsi], 0A0Dh			;add \r\n
		add		rsi, 2
		mov		rsi, offset Num2
		mov		byte ptr [rsi], 31h				;num2 = 1
		inc		rsi
		mov		word ptr [rsi], 0A0Dh			;add \r\n
		add		rsi, 2

	@Fibo:										;result = num1 + num2
		cmp		r13, 0							;count number of numbers == 0 --> exit
		jz		@Exit
		mov		rsi, offset Num1				;rsi = &num1
		mov		rdi, offset Num2				;rdi = &num2
		mov		rdx, offset Result				;rdx = &result
		call	bigsum							;bignum (rsi = &num1, rdi = &num2, rdx = &result --> return result = num1 + num2)
		;mov		r14, rsi

		mov		rsi, offset Num2				;num1 = num2
		mov		rdi, offset Num1
		call	copy							;copy(rsi = &num2, rdi = &num1 --> return num1 = num2)
		mov		rsi, offset Result				;num2 = result
		mov		rdi, offset Num2
		call	copy							;copy(rsi = &result, rdi = &num2 --> return num2 = result)

		mov		rcx, [rbp - 10h]
		mov		rdx, offset Result
		mov		r8, r14
		mov		r9, offset nByte
		mov		[rsp + 20h], r15
		call	WriteFile						;print the found fibo number

		;mov		rcx, [rbp - 10h]
		;mov		rdx, offset Space
		;mov		r8, sizeof Space
		;mov		r9, offset nByte
		;mov		[rsp + 20h], r15
		;call	WriteFile

		dec		r13								;count number of number --
		jmp		@Fibo
		
	@Exit:
		xor		rcx, rcx
		call	ExitProcess

main endp

copy proc				;copy(rsi = string, rdi = string --> rsi to rdi)
	push	rbp
	mov		rbp, rsp
	push	rbx
	push	rdx
	xor		rbx, rbx

	@Forward:
		xor		rdx, rdx
		mov		dl, byte ptr [rsi + rbx]		;dl = [rsi + rbx]
		cmp		dl, 0Dh
		jz		@Exit
		mov		byte ptr [rdi + rbx], dl		;[rdi + rbx] = [rsi + rbx]
		inc		rbx
		jmp		@Forward

	@Exit:
		mov		word ptr [rdi + rbx], 0A0Dh		;add \r\n
		add		rbx, 2
		pop		rdx
		pop		rbx
		mov		rsp, rbp
		pop		rbp
		ret

copy endp

bigsum proc							;bigsum (rsi = &num1, rdi = &num 2, rdx = &result	--> rsi = result.length)
	push	rbp
	mov		rbp, rsp
	sub		rsp, 18h
	push	rax
	push	rbx
	push	rcx
	mov		[rbp - 08h], rsi				;Num1
	mov		[rbp - 10h], rdi				;Num2
	mov		[rbp - 18h], rdx				;Results
	call	reverse							;revere(num1)
	mov		rax, rsi						;rax = num1.length
	mov		rsi, [rbp - 10h]
	call	reverse
	mov		rbx, rsi						;rbx = num2.length

	cmp		rax, rbx
	jz		@Format
	jl		@Num2Max						;Num1.length < Num2.length
	jg		@Num1Max						;Num1.length > Num2.length

	@Num1Max:
		mov		rsi, [rbp - 10h]			;Num2
		push	rbx							;Num2.length (min)
		push	rax							;Num1.length (max)
		call	insertzero
		jmp		@Format

	@Num2Max:
		mov		rsi, [rbp - 08h]			;num1
		push	rax							;Num1.length (min)
		push	rbx							;Num2.length (max)
		call	insertzero

	@Format:
		xor		rbx, rbx
		mov		rsi, [rbp - 08h]			;Num1
		mov		rdi, [rbp - 10h]			;Num2
		mov		rdx, [rbp - 18h]			;Result
		xor		r12, r12

	@Calc:
		xor		rax, rax
		mov		al, byte ptr [rsi + rbx]	;al = [num1 + rbx]
		cmp		al, 0Dh						;if al = \r --> insert mem final
		jz		@InsertByteMem	
		mov		ah, byte ptr [rdi + rbx]	;ah = [num2 + rbx]
		sub		al, 30h						;al - 48
		sub		ah, 30h						;ah - 48
		add		al, ah						;al + ah
		xor		ah, ah						;ah = 0
		add		rax, r12					;al + mem
		xor		r12, r12					;after adding --> mem = 0
		cmp		al, 10						;al > 10 --> jmp
		jnc		@High						;al > 10	--> jmp

	@Next:
		add		al, 30h						;al + 48 --> [al] = '[al]'
		mov		byte ptr [rdx + rbx], al	;result += '[al]'
		inc		rbx
		jmp     @Calc

	@High:
		mov		r12, 1						;add mem
		sub		al, 10						;al > 10 --> al - 10
		jmp		@Next

	@InsertByteMem:							;final number > 10	--> add mem
		xor		rax, rax
		mov		rax, r12					;rax = mem
		cmp		rax, 0
		je		@Exit						;mem = 0 --> done
		add		al, 30h						;mem + 48 --> '[mem]'
		mov		byte ptr [rdx + rbx], al	;add mem final
		inc		rbx

	@Exit:
		mov		word ptr [rdx + rbx], 0A0Dh			;\r\n
		add		rbx, 2
		mov		r14, rbx							;Result.length
		mov		rsi, [rbp - 18h]
		call	reverse
		pop		rcx
		pop		rbx
		pop		rax
		mov		rsp, rbp
		pop		rbp
		ret

bigsum endp

insertzero proc					;insertzero(rsi = &num, rax, rbx	--> rax = rbx (length 2 number))
	push	rbp
	mov		rbp, rsp
	push	rcx
	push	rdx
	mov		rcx, [rbp + 18h]				;Num2.length (min)
	mov		rdx, [rbp + 10h]				;Num1.length (max)

	@Insert:
		cmp		rcx, rdx
		jz		@Exit
		mov		byte ptr [rsi + rcx], 30h		;insert '0'
		inc		rcx
		jmp		@Insert

	@Exit:
		mov		word ptr [rsi + rcx], 0A0Dh		;add \r\n
		add		rcx, 2
		pop		rdx
		pop		rcx
		mov		rsp, rbp
		pop		rbp
		ret		16

insertzero endp

reverse proc			;reverse(rsi = &num		--> rdi = &num.reverse, rax = &num.length)
	push	rbp
	mov		rbp, rsp
	push	rax
	push	rcx
	push	rdx
	mov		rdi, rsi			;rdi = rsi = &num
	mov		rdx, rsi			;rdx = rsi = &num
	xor		rax, rax
	xor		rcx, rcx
	cld

	@PushSym:	
		lodsb						;al = [rsi++]
		cmp		al, 0Dh				;al = \r --> string is over --> pop from the stack down
		jz		@PopSym
		push	rax					;push [rax] to stack
		inc		rcx
		jmp		@PushSym

	@PopSym:
		test	rcx, rcx			;count database on stack is zero
		jz		@Exit				;--> exit
		xor		rax, rax
		pop		rax					;pop from the stack down --> mov to rax
		stosb						;[rdi++] = al
		dec		rcx
		jmp		@PopSym

	@Exit:
		sub		rdi, rdx				;rdi = num.length
		mov		rsi, rdi
		pop		rdx
		pop		rcx
		pop		rax
		mov		rsp, rbp
		pop		rbp
		ret

reverse endp

atoi proc				;atoi(rsi = string --> rax = (int)num)
	push	rbp
	mov		rbp, rsp
	push	rbx
	push	rdx
	xor		rax, rax
	mov		rbx, 10

	@TextNum:
		xor		rdx, rdx
		mov		dl, byte ptr [rsi]			;dl = [rsi] = (char)num
		cmp		dl, '0'
		jl		@Exit						; < '0' --> not number
		cmp		dl, '9'
		jg		@Exit						; > '9' --> not number
		sub		dl, 30h						;(char)num = (int)num
		add		rax, rdx					;rax = number
		mul		rbx							;rax *= rbx
		inc		rsi		
		jmp		@TextNum

	@Exit:
		xor		rdx, rdx
		div		rbx							;rax = number*10 --> rax/=10 = number
		pop		rdx
		pop		rbx
		mov		rsp, rbp
		pop		rbp
		ret

atoi endp

itoa proc					;itoa(rsi = (int)num --> rax = len, rsi = &string)
	push	rbp
	mov		rbp, rsp
	push	rbx
	push	rdx
	mov		rbx, rsi		;rbx = number

	sub		rsp, 20h			;shadow space
	call	GetProcessHeap		;handle
	mov		rcx, rax
	mov		rdx, 0
	mov		r8, 21
	call	HeapAlloc		;dynamically allocate array
	add		rsp, 20h		;return esp
	mov		rdi, rax		
	add		rdi, 20			;rdi = array

	mov		rax, rbx		;rax = number
	mov		rsi, rdi		;rsi = array
	mov		rbx, 10			;rbx = 10

	@NumText:
		xor		rdx, rdx
		div		rbx			;rax/=10
		add		dl, 30h					;dl = remainder
		mov		byte ptr [rdi], dl		;mov remain to array
		dec		rdi						;array --
		test	rax, rax				
		jz		@Exit					;number = 0 --> exit
		jmp		@NumText

	@Exit:	
		sub		rsi, rdi				;rsi - rdi = length (string)number
		mov		rax, rsi				;rax = length
		mov		rsi, rdi				;rsi = &string
		pop		rdx
		pop		rbx
		mov		rsp, rbp
		pop		rbp
		ret

itoa endp
end