
section .data
    sSizeArr    db "Nhap kich thuoc mang = ",0h
    sEleArr     db "Nhap tung phan tu cua mang = ", 0h
    sMin        db "Min = ", 0h
    sMax        db "Max = ", 0h  

section .bss
    buffer      resb 1000
    eArr        resd 100
    sArr        resd 0
    min         resd 0
    max         resd 0
    
section .text
global _start

_start:
    mov     rbp, rsp

    mov     rdi, 1
    mov     rsi, sSizeArr
    mov     rdx, 24
    mov     rax, 1
    syscall

    mov     rdi, 0
    mov     rsi, buffer
    mov     rdx, 5
    mov     rax, 0
    syscall                     ;read arr size
    mov     rsi, buffer
    call    _atoi
    mov     [sArr], eax         ;sArr = (int)arr size

    mov     rdi, 1
    mov     rsi, sEleArr
    mov     rdx, 29
    mov     rax, 1
    syscall

    xor     rbx, rbx
    .ArrReq:
        mov     rdi, 0
        mov     rsi, buffer
        mov     rdx, 1000
        mov     rax, 0
        syscall                 ;read arr data

    mov     rsi, buffer
    mov     r14, eArr
    .HandleArr:
        push    rsi
        call    _atoi           
        mov     dword [r14 + rbx*4], eax
        inc     rbx
        cmp     ebx, [sArr]
        jz      .DoneArr
        pop     rsi

    .NextArr:
        cmp     byte [rsi], 0Ah 
        jz      .ArrReq
        inc     rsi
        cmp     byte [rsi - 1], 20h
        jz      .HandleArr
        jmp     .NextArr

    .DoneArr:
        mov     rsi, eArr
        mov     edi, [sArr]
        mov     rdx, min
        call    _findmin
        push    rdi
        mov     rdi, 1
        mov     rsi, sMin
        mov     rdx, 6
        mov     rax, 1
        syscall
        xor     rsi, rsi
        mov     esi, [min]
        call    _itoa
        mov     byte [rsi + rax], 0Ah
        inc     rax
        mov     rdi, 1
        mov     rdx, rax
        mov     rax, 1
        syscall

        mov     rsi, eArr
        pop     rdi
        mov     rdx, max
        call    _findmax
        mov     rdi, 1
        mov     rsi, sMax
        mov     rdx, 6
        mov     rax, 1
        syscall
        xor     rsi, rsi
        mov     esi, [max]
        call    _itoa
        mov     byte [rsi + rax], 0Ah
        inc     rax
        mov     rdi, 1
        mov     rdx, rax
        mov     rax, 1
        syscall

    mov     rdi, 0
    mov     rax, 60
    syscall

_findmin:               ;findmin(rsi = $arr, edi = ArrSSize, rdx = &min ---> rdx = min)
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rcx
    mov     r8d, 0fffffffh
    xor     rbx, rbx

    .Compare:
        cmp     dword [rsi + rbx*4], r8d
        jl      .isMin

    .NextArr:
        inc     rbx
        cmp     ebx, edi
        jz      .Exit
        jmp     .Compare
    
    .isMin:
        mov     r8d, dword [rsi + rbx*4]
        jmp     .NextArr

    .Exit:
        mov     dword [rdx], r8d
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret     

_findmax:               ;findmax(rsi = $arr, edi = ArrSize, rdx = &max ---> rdx = max)
    push    rbp
    mov     rbp, rsp
    push    rbx
    mov     r8d, 0
    xor     rbx, rbx

    .Compare:
        cmp     dword [rsi + rbx*4], r8d
        jg      .isMax

    .NextArr:
        inc     rbx
        cmp     ebx, edi
        jz      .Exit
        jmp     .Compare
    
    .isMax:
        mov     r8d, dword [rsi + rbx*4]
        jmp     .NextArr

    .Exit:
        mov     dword [rdx], r8d
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret     

_atoi:                  ;atoi(rsi = &string --> rax = number)
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rdx
    xor     rax, rax
    mov     rbx, 10

    .TextNum:
        xor     rdx, rdx
        mov     dl, byte [rsi]
        cmp     dl, '0'
        jl      .Exit
        cmp     dl, '9'
        jg      .Exit
        sub     dl, 30h
        add     rax, rdx
        mul     rbx
        inc     rsi
        jmp     .TextNum
    
    .Exit:
        xor     rdx, rdx
        div     rbx
        pop     rdx
        pop     rbx
        mov     rbp, rsp
        pop     rbp
        ret

_itoa:                  ;itoa(rsi = number --> rsi = &string number) 
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rdx
    mov     rbx, rsi

    mov     rdi, 0
    mov     rax, 12
    syscall
    mov     rdi, rax
    add     rdi, 20
    mov     rax, 12
    syscall
    dec     rax
    mov     rsi, rax
    mov     rdi, rsi
    mov     rax, rbx
    mov     rbx, 10

    .NumText:
        xor     rdx, rdx
        div     rbx
        add     dl, 30h
        mov     byte [rdi], dl
        dec     rdi
        test    rax, rax
        jz      .Exit
        jmp     .NumText

    .Exit:
        sub     rsi, rdi
        mov     rax, rsi
        mov     rsi, rdi
        inc     rsi
        ; push    rax
        ; mov     rdi, 0
        ; mov     rax, 12
        ; syscall
        ; mov     rdi, rax
        ; sub     rdi, 20
        ; mov     rax, 12
        ; syscall
        ; pop     rax
        pop     rdx
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret