
section .data
    sSizeArr    db "Nhap kich thuoc mang = ",0h
    sEleArr     db "Nhap tung phan tu cua mang = ", 0h
    sOdd        db "Odd = ", 0h
    sEven       db "Even = ", 0h
    
section .bss
    buffer      resb 1000
    eArr        resd 100
    sArr        resd 0
    odd         resd 0
    even        resd 0

section .text
global _start

_start:
mov     rbp, rsp

    mov     rdi, 1
    mov     rsi, sSizeArr
    mov     rdx, 24
    mov     rax, 1
    syscall

    mov     rdi, 0
    mov     rsi, buffer
    mov     rdx, 5
    mov     rax, 0
    syscall
    mov     rsi, buffer
    call    _atoi
    mov     [sArr], eax             ;sArr = Size array

    mov     rdi, 1
    mov     rsi, sEleArr
    mov     rdx, 29
    mov     rax, 1
    syscall

    xor     rbx, rbx
    .ArrReq:
        mov     rdi, 0
        mov     rsi, buffer
        mov     rdx, 1000
        mov     rax, 0
        syscall                     ;read data

    mov     rsi, buffer             ;rsi = &buffer
    mov     r14, eArr               ;r14 = &arrSave
    .HandleArr:
        push    rsi
        call    _atoi               ;atoi(rsi = &string --> return rax = number)
        mov     dword [r14 + rbx*4], eax        ;r14 = &savearr = array save number        
        inc     rbx
        cmp     ebx, [sArr]
        jz      .DoneArr
        pop     rsi

    .NextArr:
        cmp     byte [rsi], 0Ah 
        jz      .ArrReq
        inc     rsi
        cmp     byte [rsi - 1], 20h
        jz      .HandleArr
        jmp     .NextArr

    .DoneArr:
        mov     r13, eArr
        mov     r8, 0
        mov     r9, 0
        mov     r14d, 2
        mov     rcx, 0

    .Check:
        xor     rdx, rdx
        xor     rax, rax
        mov     eax, dword [r13 + rcx*4]
        div     r14d
        cmp     dl, 1               ;odd
        jnz      .EvenCalc
        mov     eax, dword [r13 + rcx*4]
        add     r8, rax             ;r8 = sumodd
        jmp     .IncArr

    .EvenCalc:
        mov     eax, dword [r13 + rcx*4]
        add     r9, rax             ;r9 = sumeven

    .IncArr:
        inc     rcx
        cmp     rcx, [sArr]
        jnz     .Check
    ;write even
    mov     [odd], r8d
    push    rdi
    mov     rdi, 1
    mov     rsi, sOdd
    mov     rdx, 6
    mov     rax, 1
    syscall
    xor     rsi, rsi
    mov     esi, [odd]
    call    _itoa
    mov     byte [rsi + rax], 0Ah
    inc     rax
    mov     rdi, 1
    mov     rdx, rax
    mov     rax, 1
    syscall
    ;write odd
    mov     [even], r9d
    mov     rdi, 1
    mov     rsi, sEven
    mov     rdx, 7
    mov     rax, 1
    syscall
    xor     rsi, rsi
    mov     esi, [even]
    call    _itoa
    mov     byte [rsi + rax], 0Ah
    inc     rax
    mov     rdi, 1
    mov     rdx, rax
    mov     rax, 1
    syscall

    mov     rdi, 0
    mov     rax, 60
    syscall

_atoi:          ;atoi(rsi = &string --> rax = number)
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rdx
    xor     rax, rax
    mov     rbx, 10

    .TextNum:
        xor     rdx, rdx
        mov     dl, byte [rsi]
        cmp     dl, '0'
        jl      .Exit
        cmp     dl, '9'
        jg      .Exit
        sub     dl, 30h
        add     rax, rdx
        mul     rbx
        inc     rsi
        jmp     .TextNum
    
    .Exit:
        xor     rdx, rdx
        div     rbx
        pop     rdx
        pop     rbx
        mov     rbp, rsp
        pop     rbp
        ret

_itoa:          ;itoa(rsi = number --> rsi = &string number)
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rdx
    mov     rbx, rsi

    mov     rdi, 0
    mov     rax, 12
    syscall
    mov     rdi, rax
    add     rdi, 20
    mov     rax, 12
    syscall
    dec     rax
    mov     rsi, rax
    mov     rdi, rsi
    mov     rax, rbx
    mov     rbx, 10

    .NumText:
        xor     rdx, rdx
        div     rbx
        add     dl, 30h
        mov     byte [rdi], dl
        dec     rdi
        test    rax, rax
        jz      .Exit
        jmp     .NumText

    .Exit:
        sub     rsi, rdi
        mov     rax, rsi
        mov     rsi, rdi
        inc     rsi
        ; push    rax
        ; mov     rdi, 0
        ; mov     rax, 12
        ; syscall
        ; mov     rdi, rax
        ; sub     rdi, 20
        ; mov     rax, 12
        ; syscall
        ; pop     rax
        pop     rdx
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret