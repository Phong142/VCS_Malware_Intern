
section .data
    sCha    db "S = ", 0h 
    sCon    db "C = ", 0h 

section .bss
    Cha         resb 100
    Con         resb 10
    SaveIndex   resb 100

section .text
global _start

_start:
    mov     rbp, rsp

    mov     rdi, 1
    mov     rsi, sCha
    mov     rdx, 5
    mov     rax, 1
    syscall                             ;write text "S = "

    mov     rdi, 0
    mov     rsi, Cha
    mov     rdx, 100
    mov     rax, 0
    syscall                             ;Read xau Cha

    mov     rdi, 1
    mov     rsi, sCon
    mov     rdx, 5
    mov     rax, 1
    syscall                             ;write text "C = "

    mov     rsi, 0
    mov     rsi, Con
    mov     rdx, 10
    mov     rax, 0
    syscall                             ;Read xau Con

    mov     rsi, Con
    call    _length
    mov     r15, rsi                    ;r15 = Con.length

    mov     rsi, Cha
    mov     rdi, Con
    call    _find                       ;find (rsi = &Cha, rdi = &Con --> )

    mov     rsi, r12
    call    _itoa                       ;itoa(rsi = (int)num --> rsi = &num)
    mov     byte [rsi + rax], 0Ah       ;add \n final string
    inc     rax
    mov     rdi, 1
    mov     rdx, rax
    mov     rax, 1
    syscall                             ;print count index found

    mov     rdi, 1
    mov     rsi, SaveIndex              ;array save index found
    mov     byte [rsi + r13], 0Ah
    inc     r13
    mov     rdx, r13
    mov     rax, 1
    syscall                             ;print array save index found

    mov     rdi, 0
    mov     rax, 60
    syscall

_find:                  ;find(rsi = &Cha, rdi = &Con --> )
    push    rbp
    mov     rbp, rsp
    push    rax
    push    rbx
    mov     rax, rsi                        ;rax = &Cha
    mov     rbx, rdi                        ;rbx = &Con
    xor     rsi, rsi

    .FirstSym:                              ;cmp ki tu xau cha voi ki tu dau xau con
        xor     rdx, rdx
        xor     rdi, rdi
        mov     dl, byte [rax + rsi]        ;(char)xauCha
        cmp     dl, 0Ah
        jz      .Exit                       ;xauCha == \n --> xauCha end
        mov     dh, byte [rbx + 0h]         ;(char 0)xauCon
        cmp     dl, dh                      
        jz      .FindSym                    ;xauCha[i] == xauCon[0] --> jmp
        inc     rsi
        jmp     .FirstSym

    .FindSym:                               ;cmp xau cha voi xau con
        xor     rdx, rdx
        mov     dl, byte [rbx + rdi]        ;(char)xauCon
        cmp     dl, 0Ah         
        jz      .SaveNum                    ;xauCon == \n --> xauCon end
        mov     dh, byte [rax + rsi]        ;(char)xauCha
        cmp     dh, dl                      ;cmp xauCha with xauCon
        jnz     .FirstSym
        inc     rdi
        inc     rsi
        jmp     .FindSym

    .SaveNum:                               ;luu lai vi tri bat dau xau con trong xau cha
        push    rsi                         ;save count xau Cha 
        push    rax                         ;push &sCha
        sub     rsi, r15
        call    _itoa                       ;return rsi = &num
        mov     byte [rsi + rax], 0Ah
        inc     rax
        pop     rax                         ;return &sCha
        mov     rdi, SaveIndex              ;rdi = &SaveIndex array
        call    _save                       ;save(rsi = &index, rdi = &saveindex ---> rdi = &saveindex)
        pop     rsi                         ;return count xau Cha
        sub     rsi, r15                    
        inc     rsi
        inc     r12                         ;Count Index
        jmp     .FirstSym

    .Exit:
        pop     rbx
        pop     rax
        mov     rsp, rbp
        pop     rbp
        ret

_save:                                      ;save(rsi = &index, rdi = &saveindex ---> rdi = &saveindex)
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rdx
    mov     rbx, rdi                        ;rbx = &SaveIndex

    .LoopSym:
        xor     rdx, rdx
        mov     dl, byte [rsi]              ;dl = (char)index
        cmp     dl, 0Ah
        jz      .Exit                       ;dl = \n
        mov     byte [rbx + r13], dl        ;mov (char)index to array save index)
        inc     rsi
        inc     r13
        jmp     .LoopSym
    
    .Exit:
        xor     rdx, rdx
        mov     byte [rbx + r13], 20h       ;mov space to array
        inc     r13                         ;++array
        pop     rdx
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret

_length:                    ;length(rsi = &string --> return rsi = string.length)
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rdx
    mov     rdx, rsi        ;&String
    xor     rbx, rbx

    .LoopSym:
        cmp     byte [rsi], 0Ah             ;cmp (char)string with \n
        jz      .Exit                       ;==\n --> jmp exit
        inc     rsi
        jmp     .LoopSym

    .Exit:
        sub     rsi, rdx                       ;Num.length
        pop     rdx
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret

_itoa:                      ;itoa(rsi = (int)num --> rsi = &num)
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rdx
    mov     rbx, rsi        ;rbx = (int)num

    xor     rdi, rdi
    mov     rax, 12         ;sys_brk -> change data segment size
    syscall                 
    mov     rdi, rax        
    add     rdi, 20         ;rdi += 20
    mov     rax, 12         ;sys_brk
    syscall 
    dec     rax             
    mov     rsi, rax        ;new array 
    mov     rax, rbx        ;rax = (int)num
    mov     rdi, rsi        ;new array
    mov     rbx, 10         ;rbx = 10

    .NumText:
        xor     rdx, rdx
        div     rbx             ;rax = num/10
        add     dl, 30h             ;dl = remain --> (int)remain + '0'
        mov     byte [rdi], dl      ;mov (char)num to string
        dec     rdi
        test    rax, rax
        jz      .Exit
        jmp     .NumText

    .Exit:
        sub     rsi, rdi
        mov     rax, rsi            ;rax = &num.length
        mov     rsi, rdi            ;rsi = &num
        inc     rsi
        pop     rdx
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret