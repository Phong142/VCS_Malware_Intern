
section .data
    sMode       db "Select operator: ", 0Ah, "1. Addition", 0Ah, "2. Subtraction", 0Ah, "3. Multiplication", 0Ah, "4. Division", 0Ah, "0. Exit", 0Ah, 0h 
    sSelect     db "Select -> ", 0h 
    sInput		db "Input 2 operands in 2 separate lines: ", 0h
	sOutput		db "Result = ", 0h
	sRemain		db "Remainder = ", 0h

section .bss
	negt		resb 1
    select		resb 5 
	num1		resb 100 
	num2		resb 100 
	result		resq 0
	remain		resd 0

section .text
global _start

_start:
    mov     rbp, rsp

    mov     rdi, 1
    mov     rsi, sMode
    mov     rdx, 83
    mov     rax, 1
    syscall


    .startCalc:
        mov     byte [negt], 0
        mov     rdi, 1
        mov     rsi, sSelect
        mov     rdx, 10
        mov     rax, 1
        syscall

        mov     rdi, 0
        mov     rsi, select
        mov     rdx, 5
        mov     rax, 0
        syscall

        mov     r14b, [select]
        cmp     r14b, '0'               ;select = 0 --> exit
        jz      .Exit
        cmp     r14b, '4'               ;select > 4 --> select again
        jg      .startCalc

        mov     rdi, 1
        mov     rsi, sInput
        mov     rdx, 39
        mov     rax, 1
        syscall

        mov     rdi, 0
        mov     rsi, num1
        mov     rdx, 100
        mov     rax, 0
        syscall
        mov     rsi, num1
        call    _atoi
        mov     r12, rax                    ;rax = (int)num1

        mov     rdi, 0
        mov     rsi, num2
        mov     rdx, 100
        mov     rax, 0
        syscall
        mov     rsi, num2
        call    _atoi
        mov     r13, rax                    ;rax = (int)num2

        mov     r14b, [select]
        cmp     r14b, '1'
        jz      .Addd
        cmp     r14b, '2'
        jz      .Subb
        cmp     r14b, '3'
        jz      .Mull 
        cmp     r14b, '4'
        jz      .Divv

    .Addd:
        add     r12, r13
        mov     [result], r12
        jmp      .PrintResult
    .Subb:
        push    r12
        sub     r12, r13
        js      .NegResult
        mov     [result], r12
        jmp     .PrintResult
        .NegResult:
            mov     byte [negt], 1          ;cmp negative = 1 --> so am
            pop     r12
            sub     r13, r12
            mov     [result], r13
            jmp     .PrintResult
    .Mull:
        mov     rax, r12
        mul     r13
        mov     [result], rax
        jmp     .PrintResult
    .Divv:
        xor     rdx, rdx
        mov     rax, r12
        div     r13
        mov     [result], rax
    
    .PrintResult:                           ;print result
        mov     rdi, 1
        mov     rsi, sOutput
        mov     rdx, 10
        mov     rax, 1
        syscall 
        mov     rsi, [result]
        call    _itoa
        cmp     byte [negt], 1
        jz      .AddSub
    
    .Next:
        mov     byte [rsi + rax], 0Ah
        inc     rax
        mov     rdi, 1
        mov     rdx, rax
        mov     rax, 1
        syscall

    mov     dl, [select]
    cmp     dl, '4'                     ;if select = 4 --> div
    jz      .PrintRemain
    jmp     .startCalc

    .PrintRemain:                   ;print remain
        xor     rdx, rdx
        mov     rax, r12
        div     r13
        mov     [remain], edx
        mov     rdi, 1
        mov     rsi, sRemain
        mov     rdx, 13
        mov     rax, 1
        syscall
        mov     rsi, [remain]
        call    _itoa
        mov     byte [rsi + rax], 0Ah
        inc     rax
        mov     rdi, 1
        mov     rdx, rax
        mov     rax, 1
        syscall
        jmp     .startCalc

    .AddSub:
        dec     rsi
        mov     byte [rsi], '-'
        inc     rax
        jmp     .Next

    .Exit:
        mov     rdi, 0
        mov     rax, 60
        syscall

_atoi:                      ;atoi(rsi = &string --> rax = number)
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rdx
    xor     rax, rax
    mov     rbx, 10

    .TextNum:
        xor     rdx, rdx
        mov     dl, byte [rsi]
        cmp     dl, '0'
        jl      .Exit
        cmp     dl, '9'
        jg      .Exit
        sub     dl, 30h
        add     rax, rdx
        mul     rbx 
        inc     rsi
        jmp     .TextNum

    .Exit:
        xor     rdx, rdx
        div     rbx
        pop     rdx
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret

_itoa:                  ;itoa(rsi = number --> rsi = &string number)
	push	rbp
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rdx
    mov     rbx, rsi

    mov     rdi, 0
    mov     rax, 12
    syscall
    mov     rdi, rax
    add     rdi, 20
    mov     rax, 12
    syscall
    dec     rax
    mov     rdi, rax
    mov     rsi, rdi
    mov     rax, rbx
    mov     rbx, 10

    .NumText:
        xor     rdx, rdx
        div     rbx
        add     dl, 30h
        mov     byte [rdi], dl
        dec     rdi
        test    rax, rax
        jz      .Exit
        jmp     .NumText

    .Exit:
        sub     rsi, rdi
        mov     rax, rsi
        mov     rsi, rdi
        inc     rsi
        pop     rdx
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret


