
section .data
    sTextIn     db "Number = ", 0h 
    sZero       db "0", 0Ah, 0h
    sOne        db "1", 0Ah, 0h 
    Endl        db 0Ah, 0h 

section .bss
    Num     resb 5
    Num1    resb 100
    Num2    resb 100
    Result  resb 101

section .text
global _start

_start:
    mov     rbp, rsp
    
    mov     rdi, 1
    mov     rsi, sTextIn
    mov     rdx, 9
    mov     rax, 1
    syscall                         ;write text "Num = "

    mov     rdi, 0
    mov     rsi, Num
    mov     rdx, 5
    mov     rax, 0
    syscall                         ;read num

    mov     rsi, Num
    call    _atoi                   ;atoi(rsi = &num --> rax = (int)num)
    mov     r15, rax                ;r15 = (int)Num

    cmp     r15, 0      
    jz      .PrintOne               ;number of numbers == 0 --> print 1
    cmp     r15, 1
    jz      .PrintOne               ;number of numbers == 1 --> print 1

    .PrintZero:                     ;print(0)
        mov     rdi, 1
        mov     rsi, sZero
        mov     rdx, 2
        mov     rax, 1
        syscall                     ;print 0
        dec     r15                 ;number of numbers --

    .PrintOne:                      ;print(1)
        mov     rdi, 1
        mov     rsi, sOne
        mov     rdx, 2
        mov     rax, 1
        syscall
        cmp     r15, 0
        jz      .Exit               ;if r15 = 0 --> out of numbers --> exit
        dec     r15                 ;number of numbers --

    .InsertZeroOne:                 ;mov num1 = 0, num2 = 1
        mov     rsi, Num1
        mov     byte [rsi], 30h     ;num1 = 0
        inc     rsi
        mov     byte [rsi], 0Ah     ;num1 += \n
        inc     rsi
        mov     rsi, Num2
        mov     byte [rsi], 31h     ;num2 = 1
        inc     rsi
        mov     byte [rsi], 0Ah     ;num2 += \n
        inc     rsi

    .Find:                          ;result = num1 + num2
        cmp     r15, 0
        jz      .Exit               ;count number of numbers == 0 --> exit
        mov     rsi, Num1           ;rsi = &num1
        mov     rdi, Num2           ;rdi = &num2
        mov     rdx, Result         ;rdx = &result
        call    _bigsum                 ;bigsum(rsi = num1, rdi = num2, rdx = result)

        mov     rsi, Num2
        mov     rdi, Num1
        call    _copy                   ;copy(rsi = &num2, rdi = &num1 --> return num1 = num2)
        mov     rsi, Result
        mov     rdi, Num2
        call    _copy                   ;copy(rsi = &result, rdi = &num2 --> return num2 = result)

        mov     rdi, 1
        mov     rsi, Result
        mov     rdx, r14
        mov     rax, 1
        syscall                         ;print the found fibo number

        ; mov     rdi, 1
        ; mov     rsi, Endl
        ; mov     rdx, 1
        ; mov     rax, 1
        ; syscall

        dec     r15                     ;count number of number --
        jmp     .Find

    .Exit:
        xor     rdi, rdi
        mov     rax, 60
        syscall

_bigsum:            ;bigsum(rsi = num1, rdi = num2, rdx = result)
    push    rbp
    mov     rbp, rsp
    sub     rsp, 18h
    push    rax
    push    rbx
    push    rcx
    mov     [rbp - 08h], rsi                ;[rbp - 08h] = &Num1
    mov     [rbp - 10h], rdi                ;[rbp - 10h] = &Num2
    mov     [rbp - 18h], rdx                ;[rbp - 18h] = Result
    call    _reverse                        ;reverse(Num1)
    mov     rax, rsi                        ;rax = Num1.length
    mov     rsi, [rbp - 10h]
    call    _reverse
    mov     rbx, rsi                        ;rbx = Num2.length

    cmp     rax, rbx
    jz      .Format                         ;Num1.length = Num2.length
    jl      .Num2Max                        ;Num1.length < Num2,length
    ;jg      .Num1Max                        ;Num1 > Num2

    .Num1Max:                               ;num1.length > num2.length
        mov     rsi, [rbp - 10h]            ;Num2
        push    rbx                         ;Num2.length (min)
        push    rax                         ;Num1.length (max)
        call    _insertzero
        jmp     .Format

    .Num2Max:                               ;num1.length < num2.length
        mov     rsi, [rbp - 08h]            ;num1
        push    rax                         ;Num1.length (min)
        push    rbx                         ;Num2.length (max)
        call    _insertzero                 ;num1.length != num2.length --> insert 0

    .Format:                                ;return data to register
        xor     rbx, rbx
        mov     rsi, [rbp - 08h]            ;Num1
        mov     rdi, [rbp - 10h]            ;Num2
        mov     rdx, [rbp - 18h]            ;Result
        xor     r12, r12        

    .Calc:
        xor     rax, rax
        mov     al, byte [rsi + rbx]        ;al = [num1 + rbx]
        cmp     al, 0Ah                     ;if al = \n --> insert mem final
        jz      .InsertMem
        mov     ah, byte [rdi + rbx]        ;ah = [num2 + rbx]
        sub     al, 30h                     ;al - 48
        sub     ah, 30h                     ;ah - 48
        add     al, ah                      ;al + ah
        xor     ah, ah                      ;ah = 0
        add     rax, r12                    ;al + mem
        xor     r12, r12                    ;after adding --> mem = 0
        cmp     al, 10
        jnc     .High                           ;al > 10 --> jmp

    .Next:
        add     al, 30h                     ;al + 48 --> [al] = '[al]'
        mov     byte [rdx + rbx], al        ;result += '[al]'
        inc     rbx
        jmp     .Calc

    .High:
        mov     r12, 1                          ;mem = 1
        sub     al, 10                          ;al > 10 --> al - 10
        jmp     .Next

    .InsertMem:                                 ;final: cmp mem, 1 --> insert mem
        xor     rax, rax
        mov     rax, r12                        ;rax = mem
        cmp     rax, 0                          ;mem = 0 --> done
        jz      .Exit       
        add     al, 30h                         ;mem + 48 --> '[mem]'
        mov     byte [rdx + rbx], al            ;add mem final
        inc     rbx

    .Exit:
        mov     byte [rdx + rbx], 0Ah 
        inc     rbx
        mov     r14, rbx                    ;r14 = length
        mov     rsi, [rbp - 18h]
        call    _reverse
        pop     rcx
        pop     rbx
        pop     rax
        mov     rsp, rbp
        pop     rbp
        ret

_insertzero:                    ;insertzero(rsi = &num, rax, rbx	--> rax = rbx (length 2 number))
    push    rbp
    mov     rbp, rsp
    push    rcx
    push    rdx
    mov     rcx, [rbp + 18h]                ;rcx = length min
    mov     rdx, [rbp + 10h]                ;rdx = length max

    .Insert:
        cmp     rcx, rdx
        jz      .Exit
        mov     byte [rsi + rcx], 30h       ;insert '0'
        inc     rcx
        jmp     .Insert

    .Exit:
        mov     byte [rsi + rcx], 0Ah       ;add \n
        inc     rcx
        pop     rdx
        pop     rcx
        mov     rsp, rbp
        pop     rbp
        ret

_reverse:                               ;reverse(rsi = &string --> rdi = len)
    push    rbp
    mov     rbp, rsp
    push    rax
    push    rcx
    push    rdx
    xor     rax, rax
    xor     rcx, rcx
    mov     rdi, rsi                    ;rdi = rsi = &string
    mov     rdx, rsi                    ;rdx = rsi = &string

    .LoopSym:
        lodsb                           ;al = [rsi++]
        cmp     al, 0Ah                 ;al = \n --> string is over --> pop from the stack down
        jz      .PopSym
        push    rax                     ;push [rax] to stack
        inc     rcx
        jmp     .LoopSym
    
    .PopSym:
        cmp     rcx, 0                  ;count database on stack is zero
        jz      .Exit                   ;--> exit
        pop     rax                     ;pop from the stack down --> mov to rax
        stosb                           ;[rdi++] = al
        dec     rcx
        jmp     .PopSym

    .Exit:
        sub     rdi, rdx                ;rdi = len
        mov     rsi, rdi                ;rsi = len
        pop     rdx
        pop     rcx
        pop     rax
        mov     rsp, rbp
        pop     rbp
        ret


_copy:                      ;copy(rsi = string, rdi = string --> rsi to rdi)
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rdx
    xor     rbx, rbx

    .LoopSym:
        xor     rdx, rdx
        mov     dl, byte [rsi + rbx]            ;dl = [rsi + rbx]
        cmp     dl, 0Ah 
        jz      .Exit
        mov     byte [rdi + rbx], dl            ;[rdi + rbx] = [rsi + rbx]
        inc     rbx
        jmp     .LoopSym

    .Exit:
        mov     byte [rdi + rbx], 0Ah           ;add \n
        inc     rbx     
        pop     rdx
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret

_atoi:                      ;atoi(rsi = string --> rax = (int)num)
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rbx
    xor     rax, rax
    mov     rbx, 10

    .TextNum:
        xor     rdx, rdx
        mov     dl, byte [rsi]          ;dl = [rsi] = (char)num
        cmp     dl, '0'
        jl      .Exit                   ; < '0' --> not number
        cmp     dl, '9'
        jg      .Exit                   ; > '9' --> not number
        sub     dl, 30h                 ;(char)num = (int)num
        add     rax, rdx                ;rax = number
        mul     rbx                     ;rax *= 10
        inc     rsi
        jmp     .TextNum

    .Exit:
        xor     rdx, rdx
        div     rbx                     ;rax = number*10 --> rax/=10 = number
        pop     rdx
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret

_itoa:                      ;itoa(rsi = (int)num --> rsi = &num)
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rdx
    mov     rbx, rsi        ;rbx = (int)num

    xor     rdi, rdi
    mov     rax, 12         ;sys_brk -> change data segment size
    syscall                 
    mov     rdi, rax        
    add     rdi, 20         ;rdi += 20
    mov     rax, 12         ;sys_brk
    syscall 
    dec     rax             
    mov     rsi, rax        ;new array 
    mov     rax, rbx        ;rax = (int)num
    mov     rdi, rsi        ;new array
    mov     rbx, 10         ;rbx = 10

    .NumText:
        xor     rdx, rdx
        div     rbx             ;rax = num/10
        add     dl, 30h             ;dl = remain --> (int)remain + '0'
        mov     byte [rdi], dl      ;mov (char)num to string
        dec     rdi
        test    rax, rax
        jz      .Exit
        jmp     .NumText

    .Exit:
        sub     rsi, rdi
        mov     rax, rsi            ;rax = &num.length
        mov     rsi, rdi            ;rsi = &num
        inc     rsi
        pop     rdx
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret

