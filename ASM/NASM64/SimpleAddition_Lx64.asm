
section .data
    sTextIn1    db "Num1 = ", 0h
    sTextIn2    db "Num2 = ", 0h
    sTextOut    db "Result = ", 0h

section .bss
    num     resb 32

section .text
global _start

_start:
    mov     rbp, rsp

    xor     rbx, rbx                ;rbx = 0

    ;Read num1
    mov     rdi, 1                  ;hOutput
    mov     rsi, sTextIn1
    mov     rdx, 8                  ;sizeof sTextIn1
    mov     rax, 1                  ;sys_write
    syscall
    mov     rdi, 0                  ;hInput
    mov     rsi, num                ;&snum1
    mov     rdx, 32
    mov     rax, 0                  ;sys_read
    syscall
    mov     rsi, num                ;rsi = &snum1
    call    _atoi                   ;atoi(&snum1 --> (int)num1)
    add     rbx, rax                ;rbx += (int)num1

    ;Read num2
    mov     rdi, 1
    mov     rsi, sTextIn2
    mov     rdx, 8
    mov     rax, 1
    syscall
    mov     rdi, 0                  ;hInput      
    mov     rsi, num
    mov     rdx, 32
    mov     rax, 0                  ;sys_read
    syscall
    mov     rsi, num                ;rsi = &snum2
    call    _atoi                   ;atoi(&snum2 --> (int)num2)
    add     rbx, rax                ;rbx += (int)num2 --> rbx = result

    ;Write Result
    mov     rdi, 1
    mov     rsi, sTextOut
    mov     rdx, 10
    mov     rax, 1
    syscall
    mov     rsi, rbx                ;rbx = result
    call    _itoa                   ;itoa((int)result --> &result)
    mov     cl, 0Ah                  
    mov     byte [rsi + rax], cl    ;&result + 0Ah
    inc     rax
    mov     rdi, 1                  ;hOutput
    mov     rsi, rsi                ;rsi = &result
    mov     rdx, rax                ;rax = &(result).length
    mov     rax, 1                  
    syscall                         ;write result

    mov     rdi, 0
    mov     rax, 60
    syscall


    


_atoi:                  ;atoi(rsi = &num    --> return rax = (int)num)
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rdx
    xor     rbx, rbx
    xor     rax, rax
    mov     rbx, 10

    .TextNum:
        xor     rdx, rdx
        mov     dl, byte [rsi]          
        cmp     dl, '0'                 ;not number --> exit
        jl      .Exit
        cmp     dl, '9'                 ;not number --> exit
        jg      .Exit
        sub     dl, 30h                 ;dl -= 48
        add     rax, rdx                ;rax += rdx
        mul     rbx                     ;rax *= 10
        inc     rsi                     ;rsi++
        jmp     .TextNum
    
    .Exit:
        xor     rdx, rdx
        div     rbx                     
        pop     rdx
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret 

_itoa:                  ;itoa(rsi = (int)num    --> return rax = &(num).length, rsi = &num)
    push    rbp
    mov     rbp, rsp
    push    rbx
    push    rdx
    mov     rbx, rsi

    xor     rdi, rdi            ;rdi = 0
    mov     rax, 12             ;sys_brk (unsigned long brk)
    syscall
    mov     rdi, rax            
    add     rdi, 20             ;rdi = *(str + 20)
    mov     rax, 12             
    syscall                     ;sys_brk
    dec     rax
    mov     rsi, rax            ;rsi = *(str + 20)
    mov     rax, rbx            ;rbx = num
    mov     rdi, rsi            
    mov     rbx, 10

    .NumText:
        xor     rdx, rdx
        div     rbx
        add     dl, 30h
        mov     byte [rdi], dl
        dec     rdi
        cmp     rax, 0
        jz      .Exit
        jmp     .NumText

    .Exit:
        sub     rsi, rdi        ;rsi = &(num).length
        mov     rax, rsi        ;rax = &(num).length
        mov     rsi, rdi        ;rsi = &(num)
        inc     rsi
        pop     rdx
        pop     rbx
        mov     rsp, rbp
        pop     rbp
        ret